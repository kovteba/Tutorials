# Factory Method

- [Шаги реализации](#Шаги-реализации)
- [Преимущества и недостатки](#Преимущества-и-недостатки)
- [Отношения с другими паттернами](#Отношения-с-другими-паттернами)
- [Example](#Example)

## Шаги реализации
1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите 
    общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами 
    фабричного метода, перенося в него код создания различных продуктов.
4. В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.
5. На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, 
    выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
6. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания 
    соответствующего продукта из суперкласса.
7. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении 
    параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
8. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то 
    осталось — не беда, это будет его реализацией по умолчанию.
    
## Преимущества и недостатки
- [+] Избавляет класс от привязки к конкретным классам продуктов.
- [+] Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- [+] Упрощает добавление новых продуктов в программу.
- [+] Реализует принцип открытости/закрытости.


- [-] Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать 
свой подкласс создателя.

## Отношения с другими паттернами
- Многие архитектуры начинаются с применения __Фабричного метода__ (более простого и расширяемого через подклассы) и 
    эволюционируют в сторону __Абстрактной фабрики__, __Прототипа__ или __Строителя__ (более гибких, но и более сложных).
- Классы __Абстрактной фабрики__ чаще всего реализуются с помощью __Фабричного метода__, хотя они могут быть построены 
    и на основе __Прототипа__.
- __Фабричный метод__ можно использовать вместе с __Итератором__, чтобы подклассы коллекций могли создавать 
    подходящие им итераторы.
- __Прототип__ не опирается на наследование, но ему нужна сложная операция инициализации. __Фабричный метод__, 
    наоборот, построен на наследовании, но не требует сложной инициализации.
- __Фабричный метод__ можно рассматривать как частный случай __Шаблонного метода__. Кроме того, Фабричный метод 
    нередко бывает частью большого класса с Шаблонными методами.
    
## Example
```java
public interface Donut {
   void nameDonut();
}
public class AppleDonut implements Donut {
   @Override
   public void nameDonut() {
      System.out.println("Apple donut");
   }
}
public class CherryDonut implements Donut {
   @Override
   public void nameDonut() {
      System.out.println("Cherry donut");
   }
}
public class VanillaDonut implements Donut {
   @Override
   public void nameDonut() {
      System.out.println("Vanilla donut");
   }
}
```
```java
public class DonutFactory {
   public static Donut getDonut(String nameDonut){
      if (nameDonut.equals("apple")){
         return new AppleDonut();
      } else if (nameDonut.equals("vanilla")){
         return new VanillaDonut();
      } else if(nameDonut.equals("cherry")){
         return new CherryDonut();
      } else {
         return null;
      }
   }
}
```
```java
public class Application {
   public static void main(String[] args) {
      Donut cherryDonut = DonutFactory.getDonut("cherry");
      cherryDonut.nameDonut();
      Donut appleDonut = DonutFactory.getDonut("apple");
      appleDonut.nameDonut();
      Donut vanillaDonut = DonutFactory.getDonut("vanilla");
      vanillaDonut.nameDonut();
   }
}
```