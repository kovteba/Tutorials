
## Способы запустить поток?
- Переопределить `Thread#run()`, запустить через `Thread#start()`
- `new Thread(Runnable).start()`
- Через `ExecutorService`, используя utility-класс Executors

## synchronized. wait/notify/notifyAll. Как есть примитивы аналоги из пакета j.u.c?
__Дальше тезисы:__
- `synchronized` — ключевое слово, обозначающее скоуп критической секции. Можно ставить напротив объявления 
    метода, или в виде блока в коде.  
- `wait()` — ожидание треда до тех пор, пока он не будет разбужен другим тредом через notify/notifyAll.
- У `wait()` есть перегруженные версии с таймаутами.
- Тред ставится в `wait-set` на объекте
- Перед вызовом `wait()` нужно захватить монитор на данном объекте (через synchronized)
- Магия `wait()` — он отпускает лок на мониторе объекта после вызова, так чтобы в дальнейшем другой тред мог 
    захватить монитор и вызвать `notify`/`notifyAll`  
- `notify()` — будит один из ожидающих тредов, но Важно! — лок на объекте не отпускает, т.е ожидающий тред 
    разбужен будет, но с ожиданием входа в критическую секцию объекта (т.к как будто остановился на `synchronized`). 
    Так что если после notify есть тяжелые операции, это затормозит ожидающий тред, т.к тред с notify еще не отпустил 
    монитор  
- `notifyAll()` — будут разбужены все треды в wait-set, но при этом далее между тредами происходит 
    contention («сражение») за монитор
- Тред на `wait()` может быть разбужен также через interrupt, или через spurious wake-up, или по таймауту
- Так что условие выполнения, которого ожидает тред, проверяется в цикле while, а не в if
- Примитив-аналог — Condition