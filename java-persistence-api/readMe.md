# JPA

- [Java Persistence API](#Java-Persistence-API)
- [Компоненты JPA](#Компоненты-JPA)
- [Отличие JPA от JDO](#Отличие-JPA-от-JDO)
- [Entity](#Entity)
- [Отличие JPA от Hibernate](#Отличие-JPA-от-Hibernate)
- [JPA c noSQl базами](#JPA-c-noSQl-базами)
- [Entity class extends nonEntity class](#Entity-class-extends-nonEntity-class)
- [Entity class extends Entity class](#Entity-class-extends-Entity-class)
- [nonEntity class extends Entity class](#NonEntity-class-extends-Entity-class)
- [Abstract Entity class](#Abstract-Entity-class)
- [Требования JPA к Entity](#Требования-JPA-к-Entity)
- [Типы данных в первичном ключе](#Типы-данных-в-первичном-ключе)
- [Встраиваемый/Embeddable класс](#Встраиваемый/Embeddable-класс)
- [Требования JPA устанавливает к встраиваемым/Embeddable классам](#Требования-JPA-устанавливает-к-встраиваемым/Embeddable-классам)
- [Типы связей между Entity](#Типы-связей-между-Entity)
- [Mapped Superclass](#Mapped-Superclass)
- [Fetch стратегии в JPA](#Fetch-стратегии-в-JPA)
- [Три типа стратегии наследования мапинга Inheritance Mapping Strategies в JPA](#Три-типа-стратегии-наследования-мапинга-Inheritance-Mapping-Strategies-в-JPA)
- [EntityManager](#EntityManager)
- [Entity Instance's Life Cycle](#Entity-Instance-s-Life-Cycle)
- [Влияние операции persist на Entity](#Влияние-операции-persist-на-Entity)
- [Влияние операции remove на Entity](#Влияние-операции-remove-на-Entity)
- [Влияние операции merge на Entity](#Влияние-операции-merge-на-Entity)
- [Влияние операции refresh на Entity](#Влияние-операции-refresh-на-Entity)
- [Влияние операции detach на Entity](#Влияние-операции-detach-на-Entity)
- [Аннотация Basic](#Аннотация-Basic)
- [Аннотация Access](#Аннотация-Access)
- [Реализации JPA]()
    - [HIBERNATE](src/main/java/kovteba/hibernate)

## Java Persistence API
__JPA__ (_Java Persistence API_) это спецификация `Java EE` и `Java SE`, описывающая систему управления сохранением 
java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть 
существует много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ 
сохранения java объектов в базы данных (ORM систем), но один из самых популярных в Java мире.

__JPA__ - это технология, обеспечивающая объектно-реляционное отображение простых JAVA объектов и предоставляющая 
API для сохранения, получения и управления такими объектами.

__JPA_ - это спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии), часть 
__EJB3__ спецификации.

Сам __JPA__ не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как что-то будет 
действовать. JPA также определяет интерфейсы, которые должны будут быть реализованы провайдерами. Плюс к этому 
JPA определяет правила о том, как должны описываться метаданные отображения и о том, как должны работать провайдеры. 
Дальше, каждый провайдер, реализуя JPA определяет получение, сохранение и управление объектами. У каждого провайдера 
реализация разная.
Реализации JPA:
- Hibernate
- Oracle TopLink
- Apache OpenJPA

## Компоненты JPA
JPA состоит из трех основных пунктов:
- __API__ - интерфейсы в пакете `javax.persistance`. Набор интерфейсов, которые позволяют организовать взаимодействие 
    с `ORM` провайдером.
- __JPQL__ - объектный язык запросов. Очень похож на SQL, но запросы выполняются к объектам.
- __Metadata__ - аннотации над объектами. Набор аннотаций, которыми мы описываем метаданные отображения. Тогда уже 
    JPA знает какой объект в какую таблицу нужно сохранить. Метаданные можно описывать двумя способами: XML-файлом 
    или через аннотации.__JPA (Java Persistence API)__ и __Java Data Objects (JDO)__ две спецификации сохранения java объектов в базах данных. 
Если JPA сконцентрирована только на реляционных базах, то JDO более общая спецификация которая описывает ORM для любых 
возможных баз и хранилищ. В принципе можно рассматривать JPA как специализированную на реляционных баз часть 
спецификации JDO, даже при том что API этих двух спецификаций не полностью совпадает. Также отличаются 
«разработчики» спецификаций — если JPA разрабатывается как JSR, то JDO сначала разрабатывался как JSR, теперь 
разрабатывается как проект Apache JDO.

## Отличие JPA от JDO
__JPA__ (_Java Persistence API_) и __Java Data Objects__ (_JDO_) две спецификации сохранения java объектов в базах 
данных. Если `JPA` сконцентрирована только на реляционных базах, то `JDO` более общая спецификация которая 
описывает `ORM` для любых возможных баз и хранилищ. В принципе можно рассматривать `JPA` как специализированную 
на релятивистских баз часть спецификации JDO, даже при том что API этих двух спецификаций не полностью совпадает. 
Также отличаются «разработчики» спецификаций — если `JPA` разрабатывается как `JSR`, то `JDO` сначала разрабатывался 
как `JSR`, теперь разрабатывается как проект __Apache JDO__. 

## Entity
Entity это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это 
entity класс, который так же может использовать дополнительные классы, которые могут использоваться как 
вспомогательные классы или для сохранения состояния еntity.

## Отличие JPA от Hibernate
`Hibernate` одна из самых популярных открытых реализаций последней версии спецификации (_JPA 2.1_). Даже скорее самая 
популярная, почти стандарт де-факто. То есть `JPA` только описывает правила и `API`, а __Hibernate__ реализует эти 
описания, впрочем у __Hibernate__ (как и у многих других реализаций JPA) есть дополнительные возможности, не 
описанные в `JPA` (и не переносимые на другие реализации JPA).

## JPA c noSQl базами
Вообще, спецификация `JPA` говорит только о отображении java объектов в таблицы реляционных баз данных, но при этом 
существует ряд реализаций данного стандарта для noSql баз данных: Kundera, DataNucleus, ObjectDB и ряд других. 
Естественно, при это не все специфичные для реляционных баз данных особенности спецификации переносятся при 
этом на nosql базы полностью.

## Entity class extends nonEntity class
## Entity class extends Entity class
## NonEntity class extends Entity class
Может

## Abstract Entity class
Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

## Требования JPA к Entity
1. Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2. Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы 
    с аргументами),
3. Entity класс должен быть классом верхнего уровня (top-level class),
4. Entity класс не может быть enum или интерфейсом,
5. Entity класс не может быть финальным классом (final class),
6. Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods 
    or persistent final instance variables),
7. Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через 
    удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
8. Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую 
    доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter 
    методам или другим методам бизнес-логики в Entity классе),
9. Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют 
    запись этого Enity класса в базе данных.
    
## Типы данных в первичном ключе
Допустимые типы атрибутов, входящих в первичный ключ:  
- примитивные типы и их обертки Java,
- строки,
- BigDecimal и BigInteger,
- java.util.Date и java.sql.Date

В случае автогенерируемого первичного ключа (generated primary keys) допустимы только числовые типы.
В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, 
т.е. становится не переносимым (not portable).
    
## Встраиваемый/Embeddable класс
Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или 
нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции 
таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения 
каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для 
передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для 
разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких 
Entity, можно считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.

Встраиваемый класс может содержать другой встраиваемый класс.

Встриваемый класс может содержать связь с другими Entity или коллекциями Entity но только в случае если такой класс 
не используется как первичный ключ или ключ map’ы.

## Требования JPA устанавливает к встраиваемым/Embeddable классам
1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны 
    содержать первичный ключ и быть отмечены аннотацией Entity (см. вопрос 10),
2. Embeddable класс должен быть отмечен аннотацией Embeddable или описан в XML файле конфигурации JPA.

## Типы связей между Entity
Существуют следующие четыре типа связей:  
1. __OneToOne__ (связь один к одному, то есть один объект Entity может связан не больше чем с один объектом другого Entity)
2. __OneToMany__ (связь один ко многим, один объект Entity может быть связан с целой коллекцией других Entity)
3. __ManyToOne__ (связь многие к одному, обратная связь для OneToMany)
4. __ManyToMany__ (связь многие ко многим)

Каждую из которых можно разделить ещё на два вида:
- __Bidirectional__ - ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть 
    ссылка на Entity B, в Entity B есть ссылка на Entity A, Entity A считается владельцем этой связи (это важно 
    для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).
- __Undirectional__ - ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только 
    у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.
    
## Mapped Superclass
__Mapped Superclass__ это класс от которого наследуются Entity, он может содержать аннотации JPA, однако сам 
такой класс не является `Entity`, ему не обязательно выполнять все требования установленные для Entity (например, 
он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. 
Такой класс должен быть отмечен аннотацией MappedSuperclass или соответственно описан в xml файле.

## Fetch стратегии в JPA
В JPA описаны два типа fetch стратегии:
1. __LAZY__ — данные поля будут загружены только во время первого доступа к этому полю,
2. __EAGER__ — данные поля будут загружены немедленно.

## Три типа стратегии наследования мапинга Inheritance Mapping Strategies в JPA
В JPA описаны три стратегии наследования мапинга (Inheritance Mapping Strategies), то есть как JPA будет работать с 
классами-наследниками Entity:  
1. одна таблица на всю иерархию наследования (a single table per class hierarchy) — все enity, со всеми наследниками 
    записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. 
    Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются 
    в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение 
    «cat» или «dog».Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из 
    классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется 
    и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null 
    для dog и cat соответственно.   
2. объединяющая стратегия (joined subclass strategy) — в этой стратегии каждый класс enity сохраняет данные в свою 
    таблицу, но только уникальные колонки (не унаследованные от классов-предков) и первичный ключ, а все 
    унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь 
    (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы 
    animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет 
    ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. 
    Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.   
3. одна таблица для каждого класса (table per concrete class strategy) — тут все просто каждый отдельный 
    класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в 
    таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка 
    полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое 
    количество отдельных sql запросов или использование UNION запроса.

## EntityManager
EntityManager это интерфейс, который описывает API для всех основных операций над Enitity, получение данных и 
других сущностей JPA. По сути главный API для работы с JPA.   

Основные операции:   
1. Для операций над Entity: persist (добавление Entity под управление JPA), merge (обновление), remove (удаления), 
    refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Enity от изменений в 
    других thread),
2. Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, 
    contains, createNamedStoredProcedureQuery, createStoredProcedureQuery
3. Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
4. Работа с EntityGraph: createEntityGraph, getEntityGraph
5. Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear.

## Entity Instance s Life Cycle
У Entity объекта существует четыре статуса жизненного цикла: new, managed, detached, или removed. Их описание
1. __new__ — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
2. __managed__ — объект создан, управляется JPA, имеет сгенерированные первичные ключи
3. __detached__ — объект был создан, но не управляется (или больше не управляется) JPA
4. __removed__ — объект создан, управляется JPA, но будет удален после commit’a транзакции
    
## Влияние операции persist на Entity
1. Если статус Entity new, то он меняется на managed и объект будет сохранен в базу при commit’е транзакции или в 
    результате flush операций
2. Если статус уже managed, операция игнорируется, однако зависимые Entity могут поменять статус на managed, 
    если у них есть аннотации каскадных изменений
3. Если статус removed, то он меняется на managed
4. Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.

## Влияние операции remove на Entity
1. Если статус Entity new, операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у 
    них есть аннотации каскадных изменений и они имели статус managed
2. Если статус managed, то статус меняется на removed и запись объект в базе данных будет удалена при commit’е 
    транзакции (так же произойдут операции remove для всех каскадно зависимых объектов)
3. Если статус removed, то операция игнорируется
4. Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.

## Влияние операции merge на Entity
1. Если статус detached, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом, 
    либо создан новый managed в который скопируются данные,
2. Если статус Entity new, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта,
3. Если статус managed, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если 
    их статус не managed,
4. Если статус removed, будет выкинут exception сразу или на этапе commit’а транзакции.

## Влияние операции refresh на Entity
1. Если статус Entity managed, то в результате операции будут востановленны все изменения из базы данных данного 
    Entity, так же произойдет refresh всех каскадно зависимых объектов,
2. Если статус new, removed или detached, будет выкинут exception.
    
## Влияние операции detach на Entity
1. Если статус Entity managed или removed, то в результате операции статус Entity (и всех каскадно-зависимых объектов) 
    станет detached.
2. Если статус new или detached, то операция игнорируется.

## Аннотация Basic
Basic — указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации 
можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.

## Аннотация Access
Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то 
есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), 
имеющие гетеры (getter) и сетеры (setter).
    
## Виды cache в JPA
JPA говорит о двух видов кэшей (cache):  
1. __first-level cache (кэш первого уровня)__ — кэширует данные одной транзакции,
2. __second-level cache (кэш второго уровня)__ — кэширует данные дольше чем одна транзакция. Провайдер JPA может, 
    но не обязан реализовывать работу с кэшем второго уровня. Такой вид кэша позволяет сэкономить время доступа и 
    улучшить производительность, однако оборотной стороной является возможность получить устаревшие данные.