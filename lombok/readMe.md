## Lombok

- [@NonNull](#@NonNull)
- [@Cleanup](#@Cleanup)
- [@Getter и @Setter](#@Getter-и-@Setter)
- [@Tolerate](#@Tolerate)
- [@ToString](#@ToString)
- [@EqualsAndHashCode](#@EqualsAndHashCode)
- [@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor](#@NoArgsConstructor-@RequiredArgsConstructor-@AllArgsConstructor)
- [@Data](#@Data)
- [@Value](#@Value)
- [@Builder](#@Builder)
- [@SneakyThrows](#@SneakyThrows)
- [@Synchronized](#@Synchronized)
- [@Log](#@Log)
- [Настройка Lombok](#Настройка-Lombok)



### @NonNull
С использованием lombok:   
```java
public class NonNullExample extends Something {
    private String name;
    
    public NonNullExample(@NonNull Person person) {
        super("Hello");
        this.name = person.getName();
    }
}
```

Чистая Java:   
```java
public class NonNullExample extends Something {
    private String name;
    
    public NonNullExample(@NonNull Person person) {
        super("Hello");
        if (person == null) {
            throw new NullPointerException("person");
        }
        this.name = person.getName();
    }
}
```

>Аннотация @NonNull на параметре примитивного типа вызовет предупреждение при компиляции. Никаких проверок не 
>будет сгенерировано.

---

### @Cleanup  
Вы можете использовать @Cleanup, для того чтобы гарантировать, что данный выделенный ресурс автоматически очистит 
за собой, до того как он выйдет за пределы области видимости. Вы делаете это указывая аннотацию  @Cleanup для 
любой локальной переменной вот так:   
```java
@Cleanup InputStream in = new FileInputStream("some/file")
```
В результате в конце области видимости будет вызываться 
```java
in.close().
```  

Этот вызов гарантирует использование конструкции try/finally. 

Если тип, ресурсы которого вы хотите очистить, не имеет метода `close()`, но имеет другой метод без аргументов, 
то вы можете указать имя метода:
```java
@Cleanup("dispose") org.eclipse.swt.widgets.CoolBar bar = new CoolBar(parent, 0);
```
По умолчанию используется метод `close()`. Методы очистки с аргументами не могут быть вызваны с помощью `@Cleanup`.

С использованием lombok:   
```java
public class CleanupExample {
    public static void main(String[] args) throws IOException {
        @Cleanup InputStream in = new FileInputStream(args[0]);
        @Cleanup OutputStream out = new FileOutputStream(args[1]);
        byte[] b = new byte[10000];
        while (true) {
            int r = in.read(b);
            if (r == -1) break;
            out.write(b, 0, r);
        }
    }
}
```

Чистая Java:   
```java
public class CleanupExample {
    public static void main(String[] args) throws IOException {
        InputStream in = new FileInputStream(args[0]);
        try {
            OutputStream out = new FileOutputStream(args[1]);
            try {
                byte[] b = new byte[10000];
                while (true) {
                    int r = in.read(b);
                    if (r == -1) break;
                    out.write(b, 0, r);
                }
            } finally {
                if (out != null) {
                    out.close();
                }
            }
        } finally {
            if (in != null) {
                in.close();
            }
        }
    }
}
```

---

### @Getter и @Setter
Сгенерированные методы получения/установки значения имеют модификатор доступа `public`, если вы не укажете 
явно AccessLevel, как показано в примере ниже. Доступные уровни доступа: `PUBLIC`, `PROTECTED`, `PACKAGE` 
и `PRIVATE`.

Вы можете также вручную запретить генерацию метода получения/установки для любого поля с помощью `AccessLevel.NONE`.

__Поддерживаемые ключи конфигурации:__

```
lombok.accessors.chain = [true | false] (default: false)
```
Если установлен в true, то сгенерированные методы установки значения возвращают this (вместо void). Явно указанный 
параметр chain в аннотации @Accessors имеет приоритет перед этой настройкой.

```
lombok.accessors.fluent = [true | false] (default: false)
```
Если установлено в true, то генерирует методы установки и получения значений без стандартных префиксов get и set, 
а вместо этого методы используют то же имя, что и поле. Явно указанный параметр fluent в @Accessors имеет 
приоритет над этой настройкой.

```
lombok.accessors.prefix += a field prefix (default: empty list)
```
Это свойство-список. Значения могут быть добавлены с помощью оператора +=. Унаследованные префиксы из 
родительского файла конфигурации могут быть удалены с помощью оператора -=. Lombok разделяет любые 
подходящие префиксы от имени, для того чтобы определить имя сгенерированных методов получения/установки 
значений. Например, если m — это один из префиксов из этой настройки, то поле с именем mFoobar будет 
иметь метод установки значения getFoobar(), а не getMFoobar(). Явно указанный параметр prefix в 
@Accessors имеет приоритет перед этой настройкой.

```
lombok.getter.noIsPrefix = [true | false] (default: false)
```
Если установлено в true, то сгенерированные методы получения значений для логических полей будут использовать 
префикс get вместо префикса по умолчанию, и любой сгенерированный код, вызывающий методы получения значения, 
вроде @ToString, будет также использовать get вместо is.

```
lombok.setter.flagUsage = [warning | error] (default: not set)
```
Lombok будет помечать любое использование @Setter как предупреждение или ошибку, если настроено.

```
lombok.getter.flagUsage = [warning | error] (default: not set)
```
Lombok будет помечать любое использование @Getter как предупреждение или ошибку, если настроено.

Mетод getFoo() не будет генерироваться, если уже существует метод getFoo(String… x), даже если технически 
возможно сделать такой метод. Это предостережение, для того чтобы предотвратить недоразумения. Если 
генерация метода пропущена по этой причине, то появляется предупреждение.  Вы можете пометить любой 
метод `@lombok.experimental.Tolerate`, чтобы скрыть их.

---

### @Tolerate
Пометить метод для того чтобы скрыть его от Lombok

---

### @ToString
По умолчанию он возвращает имя класса и значения всех полей, разделённые запятыми.    
По умолчанию все нестатические поля выводятся.

Если вы хотите пропустить некоторые поля, то вы можете перечислить их в параметре `exclude`. Или вы можете указать 
только поля, которые нужно выводить в параметре `of`.    
```
@ToString(exclude = "id")
```

__Поддерживаемые ключи конфигурации:__
```
lombok.toString.includeFieldNames = [true | false] (default: true)
```
Обычно lombok генерирует фрагмент результата toString для каждого поля в виде «-имя поля = значение» Если 
эту настройку установить в false, то lombok будет пропускать имя поля и просто генерировать разделённый 
запятыми список значений полей. Параметр аннотации includeFieldNames, если указан, имеет приоритет перед 
этой настройкой.

```
lombok.toString.doNotUseGetters = [true | false] (default: false)
```
Если установлено в true, то lombok при генерации методов toString() будет получать доступ к полям напрямую 
вместо использования методов получения значений. Параметр аннотации doNotUseGetters, если явно указан, 
имеет приоритет перед этой настройкой.

```
lombok.toString.flagUsage = [warning | error] (default: not set)
```
Lombok будет помечать все использования @ToString предупреждением или ошибкой, если указано.

Если уже есть метод с именем toString без аргументов, независимо от типа возвращаемого значения, 
никакой метод генерироваться не будет, а вместо этого появится предупреждение, объясняющее, 
что аннотация `@ToString` ничего не делает.

---

### @EqualsAndHashCode
К любому объявлению класса может быть применена аннотация `@EqualsAndHashCode`, чтобы lombok сгенерировал 
методы `equals(Object other)` и `hashCode()`. По умолчанию используются все нестатические, не-transient поля, 
но вы можете исключить некоторые поля, перечислив их в параметре `exclude`. Или вы можете явно указать, 
какие поля вы хотите использовать, перечислив их в параметре `of`.

__Поддерживаемые ключи конфигурации:__   
```
lombok.equalsAndHashCode.doNotUseGetters = [true | false] (default: false)
```
Если установлен в true, то lombok будет обращаться к полям напрямую вместо использования методов получения 
значений (если есть) при генерации методов equals и hashCode. Параметр аннотации doNotUseGetters, если явно 
указан, имеет приоритет перед этой настройкой.

```
lombok.equalsAndHashCode.flagUsage = [warning | error] (default: not set)
```
Lombok будет помечать любое использование @EqualsAndHashCode предупреждением или ошибкой, если настроено.

---

### @NoArgsConstructor @RequiredArgsConstructor @AllArgsConstructor
__@NoArgsConstructor__ генерирует конструктор без параметров. Если это невозможно (потому что поля final), то 
возникает ошибка компиляции. Если используется @NoArgsConstructor(force = true), то все `final` поля 
инициализируются `0` / `false` / `null`.

__@RequiredArgsConstructor__ генерирует конструктор с 1 параметром для каждого поля, которое требует 
специальной обработки. Все неинициализированные final поля получают параметр, также как все остальные 
поля, помеченные @NonNull, которые не иницилизированы при объявлении. Для этих случаев также генерируется 
явная проверка на null. Конструктор бросает исключение NullPointerException, если какой-либо из параметров, 
предназначенный для полей, помеченных @NonNull содержит null. Порядок этих параметров совпадает с порядком 
появления полей в 

@RequiredArgsConstructor генерирует конструктор, принимающий значения для каждого final  поля или поля с 
аннотацией @NonNull  Аргументы конструктора будут сгенерированы в том порядке, в котором поля перечислены 
в классе. Для @NonNull полей конструктор так же будет проверять, чтобы в него не передали значение null.

__@AllArgsConstructor__ генерирует конструктор с одним параметром для каждого поля в классе. Поля, 
помеченные `@NonNull`, имеют проверку на null для этих параметров.

---

### @Data
__@Data__ — это удобная сокращённая аннотация, которая содержит в себе возможности из `@ToString`, 
`@EqualsAndHashCode`, `@Getter` / `@Setter` и `@RequiredArgsConstructor`. Другими словами, @Data 
генерирует весь бойлерплейт код методы получения значений для всех полей, методы установки значений 
для не final полей, подходящий toString, equals и hashCode для этих полей, конструктор, инициализирующий 
все final поля и все не final поля, у которых нет выражения инициализации, и которые помечены @NonNull, 
для того чтобы гарантировать, что поле никогда не будет null (с исключением что никаких конструкторов 
не генерируется, если уже есть явно написанный конструктор).   
Однако параметры этих аннотаций (`callSuper`, `includeFieldNames` и `exclude`) не могут быть установлены с `@Data`. 
Если вам нужно установить значение этих параметров отличное от значения по умолчанию, то просто явно добавьте 
эти аннотации. @Data достаточно умён, чтобы учитывать их.

Все поля помеченные как transient не будут рассматриваться в hashCode и equals.

@Data может обрабатывать шаблонные параметры для полей. Для того чтобы уменьшить бойлерплейт-код при создании 
объектов для классов с шаблонами, вы можете использовать параметр staticConstructor, чтобы сгенерировать 
приватный конструктор, а также статический метод, возвращающий новый экземпляр. В этом случае javac будет 
выводить тип переменной. Таким образом, с объявлением класса 
 ```
 @Data(staticConstructor="of") class Foo { private T x;}
```
,вы можете создавать экземпляры класса Foo так: `Foo.of(5);`, вместо `new Foo(5);`.

__Поддерживаемые ключи конфигурации:__   
```
lombok.data.flagUsage = [warning | error] (default: not set)
```
Lombok будет помечать любое использование @Data предупреждением или ошибкой, если настроено.

---

### @Value
Все поля делаются приватными и final по умолчанию, методы установки значений не генерируются.

---

### @Builder
Аннотация @Builder создаёт составной builder API для ваших классов.

`@Builder` даёт вам возможность автоматически генерировать код, необходимый для создания экземпляров 
ваших классов кодом вида:   
```java
Person
    .builder()
    .name("Adam Savage")
    .city("San Francisco")
    .job("Mythbusters")
    .job("Unchained Reaction")
    .build();
```

@Builder может быть указан для класса или конструктора или статического метода. Чаще всего он указывается 
для класса или для конструктора.

#### @Singular   
Если один из параметров помечен аннотацией `@Singular`, то Lombok считает, что этот элемент builder-а 
является коллекцией, и генерирует 2 метода добавления, вместо метода установки.  Один метод добавляет 
один элемент в коллекцию, а другой метод добавляет все элементы из другой коллекции в эту коллекцию.


---

### @SneakyThrows
Аннотация @SneakyThrows может быть использована для бросания проверяемых исключений без их объявления в throws метода.

---

### @Synchronized
Аннотация @Synchronized — это безопасный вариант модификатора synchronized. Так же как и synchronized, 
эта аннотация может быть использована только для статических методов и методов экземпляров классов. 
Он работает так же, как и ключевое слово synchronized, но ставит блокировку на другом объекте. 
Ключевое слово ставит блокировку на this, а аннотация — на поле с именем $lock, которое приватно. 
Если этого поля не существует, то оно создаётся. Если вы ставите аннотацию для статического метода, 
то аннотация блокирует статическое поле с именем $LOCK.

---

### @Getter(lazy=true)
Новое в Lombok 0.10: Вы можете позволить Lombok генерировать метод получения значения, который будет 
вычислять значения один раз и кешировать его для последующего использования. Это может быть полезно, 
когда вычисление значения требует значительного процессорного времени, или когда значения занимает 
большой объём памяти. Чтобы использовать эту возможность, создайте приватное final поле, 
инициализируйте его выражением, сложным для вычисления, и добавьте к нему аннотацию 
@Getter(lazy=true). Поле будет скрыто от вашего остального кода, и выражение будет вычисляться 
только один раз, при первом вызове метода получения значения. Здесь нет специальных значений (то есть 
даже если результатом вычисления будет null, то результат всё равно будет кеширован), и ваше сложное 
вычисление не обязано быть потокобезопасным, так как Lombok заботится о блокировках.

---

### @Log
Вы можете добавить аннотацию логгера к любому классу, чтобы Lombok генерировал поле логгера. Поле логгера 
имеет имя log, и тип поля зависит от выбранного логгера.

__Доступно шесть типов логгеров:__
- `@CommonsLog`
```
private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);
```
- `@Log`
```
private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());
```
- `@Log4j`
```
private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);
```
- `@Log4j2`
```
private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);
```
- `@Slf4j`
```private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);```
- `@XSlf4j`
```
private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);
```

По умолчанию тема (или имя) логгера будет имя класса, аннотированного с @Log. Это может быть изменено с помощью 
параметра topic. 
Например:  
```
@XSlf4j(topic="reporting")
```

---

### Настройка Lombok
Обычно пользователи Lombok располагают файл lombok.config со своими настройками в корне своего workspace-а 
со специальной настройкой config.stopBubbling = true , чтобы указать Lombok-у, что это корневой каталог.  
Затем вы можете создать свои файлы lombok.config в любых подкаталогах (обычно отображающих отдельные 
проекты и их исходные файлы) с отличающимися настройками.

```
java -jar lombok.jar config -g --verbose
```
Результатом работы утилиты config будет корректный файл lombok.config.

Утилита config может быть также использована для отображения конечной конфигурации, используемой для любого 
файла исходников, с помощью передачи этих аргументов.

```
lombok.accessors.chain
```
Если установлено в true, то генерируемые методы установки значений можно выстраивать в цепочки (они возвращают this).

```
lombok.accessors.fluent
```
Если установлено в true, то сгенерированные методы установки значений и методы получения значений будут иметь 
то же имя, что и имя поля, без префиксов get и set.

```
lombok.anyConstructor.suppressConstructorProperties
```
Если установлено в true, то Lombok будет генерировать аннотацию `@java.beans.ConstructorProperties`  при 
генерации конструкторов. Это особенно полезно при разработке для GWT и Android.

```
lombok.log.fieldName
```
Имя генерируемого поля log (по умолчанию — log).

```
lombok.(featureName).flagUsage
```
Позволяет принудительно остановить мешающую возможность Lombok. Возможные значения для этого ключа: warning и error. 
Некоторые примеры значений для (featureName): "experimental"  (помечает использование любой экспериментальной 
возможности), "builder" , "sneakyThrows" , или "extensionMethod" .

Файлы конфигураций иерархические. Все настройки применяются ко всем исходным файлам в этом каталоге и ко всем 
исходным файлам в подкаталогах, но настройки, более близкие к исходному файлу, имеют приоритет.


Чтобы Lombok не смотрел в родительские каталоги для других конфигурационных файлов, используйте ключ:
```
config.stopBubbling = true
```
Его рекомендуется располагать в вашем workspac-е.

---






















