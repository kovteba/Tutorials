# Dependency injection, Bean, IoC

- [Паттерн DI или IoC](#Паттерн-DI-или-IoC)
- [Преимущества Dependency Injection](#Преимущества-Dependency-Injection)
- [IoC контейнер Spring](#IoC-контейнер-Spring)
- [Реализация DI в Spring Framework](#Реализация-DI-в-Spring-Framework)
- [Spring Bean](#Spring-Bean)
- [Жизненный цикл Spring Bean](#Жизненный-цикл-Spring-Bean)
- [Scope Spring Bean](#Scope-Spring-Bean)
    - [Singleton](#Singleton)
    - [Non Singleton](#Non-Singleton)
- [BeanFactory в Spring](#BeanFactory-в-Spring)
- [Концепции инверсии управления](#Концепции-инверсии-управления)
- [Dependency Lookup](#Dependency-Lookup)
    - [Dependency Pull](#Dependency-Pull)
    - [Contextualized Dependency](#Contextualized-Dependency)
    - [Lookup Method Injection](#Lookup-Method-Injection)
- [Dependency Injection](#Dependency-Injection)
    - [Constructor Dependency Injection](#Constructor-Dependency-Injection)
    - [Setter Dependency Injection](#Setter-Dependency-Injection)
    - [Method Replacement](#Method-Replacement)
- [Режимы автосвязывания](#Режимы-автосвязывания)
- [@Autowired](#@Autowired)
    - [Поля](#Поля)
    - [Сетер](#Сетер)
    - [Конструктор](#Конструктор)
- [@Qualifier](#@Qualifier)
- [Инициализация Bean](#Инициализация-Bean)
    - [@PostConstruct](#@PostConstruct)
    - [init method](#init-method)
    - [Interface InitializingBean](#Interface-InitializingBean)
- [Уничтожение Bean](#Уничтожение-Bean)
    - [@PreDestroy](#@PreDestroy)
    - [destroy method](#destroy-method)
    - [Interface DisposableBean](#Interface-DisposableBean)
- [@Component](#@Component)
- [Add list](#Add-list)
- [Interface BeanNameAware](#Interface-BeanNameAware)
- [FactoryBean](#FactoryBean)
- [Потокобезопасен ли Spring bean](#Потокобезопасен-ли-Spring-bean)
- [](#)
- [](#)


---

## Паттерн DI или IoC
__Dependency injection (DI)__ - паттерн проектирования и архитектурная модель, так же известная как 
__Inversion of Control (IoC)__. DI описывает ситуацию, когда один объект реализует свой функционал через 
другой объект. Например, соединение с базой данных передается конструктору объекта через аргумент, 
вместо того чтобы конструктор сам устанавливал соединение. Существуют три формы внедрения (но не типа) 
зависимостей:   

- сэттер
- конструктор
- внедрение путем интерфейса

__DI__ - это способ достижения слабой связанности.   
__IoC__ предоставляет возможность объекту получать ссылки на свои зависимости. Обычно это реализуется через 
lookup-метод. Преимущество __IoC__ в том, что эта модель позволяет отделить объекты от реализации механизмов, 
которые он использует. В результате мы получаем большую гибкость как при разработке приложений, так и при их 
тестировании.

---

## Преимущества Dependency Injection
К преимуществам DI можно отнести:  
- Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения 
    объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую 
    этот код очень прост - при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
- Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. 
    Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
- Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению 
    зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, 
    удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) 
    зависимостей там, где они нужны - внутри зависимого класса. Это приводит к распространению зависимостей 
    по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация 
    об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию 
    в XML-файлах или Java классах).
- Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена 
    зависимостей. Это особенно полезно при тестировании приложения.
- Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает 
    проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд 
    средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе

---

## IoC контейнер Spring
По своей сути __IoC__(Inversion of control), а следовательно, и __DI__, направлены на то, чтобы предложить простой 
механизм для предоставления зависимостей компонента (часто называемых коллабораторами объекта) и управления 
этими зависимостями на протяжении всего их жизненного цикла. Компонент, который требует определенных зависимостей, 
зачастую называют зависимым объектом или, в случае __IoC__, целевым объектом. __IoC__ предоставляет службы, 
через которые компоненты могут получать доступ к своим зависимостям, и службы для взаимодействия с зависимостями 
в течение их времени жизни.   

__В общем случае IoC может быть расщеплена на два подтипа:__    
- инверсия управления (Dependency Injection)
- инверсия поиска (Dependency Lookup).   

__Инверсия управления__ — это крупная часть того, что делает Spring, и ядро реализации Spring основано на инверсии 
управления, хотя также предоставляются и средства Dependency Lookup. Когда платформа Spring предоставляет 
коллабораторы зависимому объекту автоматически, она делает это с использованием инверсии управления 
(Dependency Injection). В приложении, основанном на Spring, всегда предпочтительнее применять Dependency Injection 
для передачи коллабораторов зависимым объектам вместо того, чтобы заставлять зависимые объекты получать 
коллабораторы через поиск.

---

## Реализация DI в Spring Framework
Реализация __DI__ в __Spring__ основана на двух ключевых концепциях Java - компонентах JavaBean и интерфейсах. При 
использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей 
внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java 
классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые __POJO__ (Plain Old Java 
Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые 
являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при 
проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов 
можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для 
удовлетворения их зависимости.

---

## Spring Bean
Термин __бин__ (англ. Bean) - в Spring используется для ссылки на любой компонент, управляемый контейнером. 
Обычно бины на определенном уровне придерживаются спецификации JavaBean, но это не обязательно особенно если 
для связывания бинов друг с другом планируется применять __Constructor Injection__. Для получения экземпляра 
бина используется ApplicationContext. __IoC__ контейнер управляет жизненным циклом спринг бина, областью 
видимости и внедрением.

Каждый бин должен иметь, по крайней мере, одно имя, которое является уникальным внутри содержащего бин 
контекста `ApplicationContext`. При определении имени бина платформа Spriпg следует простому процессу 
распознавания. Если в дескрипторе `<bean>` предусмотрен атрибут __id__, его значение применяется в 
качестве имени. Коrда атрибут __id__ не указан, Spring ищет атрибут __name__, и если он определен, 
то используется первое имя, заданное в атрибуте name. (Мы говорим первое имя, потому что в атрибуте 
__name__ допускается определять множество имен) Если не указан ни атрибут __id__, ни атрибут __name__, 
в качестве имени платформа Spring применяет имя класса бина, разумеется, при условии, что другие бины 
не используют то же самое имя класса. В случае если множество бинов с отсутствующими атрибутами __id__ 
и __name__ имеют одно и то же имя класса, Spring сгенерирует исключение 
`org.springframework.beans.factory.NoSuchBeanDefinitionException` при внедрении во время
инициализации `ApplicationContext`.

Платформа Spring разрешает бину иметь более одного имени. Для этого в атрибуте `name` дескриптора `<bean>` бина 
необходимо указать список имен, разделенных пробелами, запятыми или точками с запятой. Это можно сделать вместо 
применения атрибута id или в сочетании с ним.
Чтобы определить псевдонимы для имен бинов Spring, кроме атрибута `name` можно воспользоваться дескриптором 
`<alias>`. 
```xml
<?xrnl version = "l.O" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi = "http://www.wЗ.org/2001/XМLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="namel" name="name2 name3,name4;name5" class = "java.lang.String"/>
    <alias name = "namel" alias = "nameб"/>
</beans>
```

Существует несколько способов работы с классами в Spring:
XML конфигурация:
```xml
<bean name="myBean" class="kovteba.beans.MyBean"></bean>
```
Java based конфигурация. Все настройки и указания бинов прописываются в java коде:
```java
@Configuration
@ComponentScan
public class MyConfiguration {
   
   @Bean
   public MyService getService(){
      return new MyService();
   }
}
```
Для извлечения бина из контекста используется следующий подход:
```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class );
MyService service = ctx.getBean(MyService.class );
```
Annotation based конфигурация. Можно использовать внутри кода аннотации @Component, @Service, @Repository, 
@Controller для указания классов в качестве спринг бинов. Для их поиска и управления контейнером прописывается 
настройка в xml файле:
```xml
<context:component-scan base-package="kovteba.beans"/>
```

---

## Жизненный цикл Spring Bean
![beanlife](img/beanlife.png)  
__Жизненный цикл Spring бина__  время существования класса. Spring бины инициализируются при инициализации Spring 
контейнера и происходит внедрение всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё содержимое. 
Если нам необходимо задать какое-либо действие при инициализации и уничтожении бина, то нужно воспользоваться 
методами `init()` и `destroy()`. Для этого можно использовать аннотации `@PostConstruct` и `@PreDestroy`.
```java
@PostConstruct
public void init(){
   System.out.println("INIT")
}
@PreDestroy
public void destroy(){
   System.out.println("DESTROY")
}
```
Или через xml конфигурацию:
```xml
<bean name="myBean" class="kovteba.MyBean" init-method="init" destroy-method="destroy">
    <property name="someProp" ref="someProp"></property>
</bean>
```

Высокоуровневый обзор того, как Spring управляет жизненным циклом бинов внутри их контейнера:   
![Life](img/Spring-control-bean-life.png)

---

## Scope Spring Bean
В Spring предусмотрены различные области времени действия бинов:
- __Singleton__  может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если 
    не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.
- __prototype__  создается новый экземпляр при каждом запросе.
    destroy метод не вызывается
- __request__   аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. 
    Создается новый экземпляр при каждом HTTP request.
- __session__  новый бин создается в контейнере при каждой новой HTTP сессии.
- __global-session__: используется для создания глобальных бинов на уровне сессии для Portlet  приложений.

### Singleton
- __Совместно используемый объект без состояния__. Имеется объект, не поддерживающий состояние, и множество 
    зависимых от него объектов. Поскольку состояние не поддерживается и, следовательно, синхронизация не 
    нужна, не потребуется создавать новый экземпляр бина каждый раз, когда он необходим зависимому объекту 
    для какой-то обработки.
- __Совместно используемый объект с состоянием только для чтения__. Этот сценарий похож на предыдущий, 
    но здесь поддерживается состояние, предназначенное только для чтения. В данном случае синхронизация 
    по-прежнему не нужна, поэтому создание экземпляра для каждого запроса бина просто увеличивает накладные расходы.
- __Совместно используемый объект с совместно используемым состоянием__. Если нужен бин, состояние которого 
    должно использоваться совместно, то одиночный экземпляр будет идеальным выбором. В этом случае потребуется 
    обеспечить как можно более детализированную синхронизацию при записи состояния.
- __Объекты с высоким коэффициентом использования и записываемым состоянием.__ Если есть бин, который интенсивно 
    применяется в приложении, вы можете обнаружить, что сохранение его одиночным и синхронизация всего доступа
    к нему по записи позволяют обеспечить более высокую производительность, чем постоянное создание сотен 
    экземпляров этого объекта. Используя такой подход, старайтесь обеспечить как можно более детализированную 
    синхронизацию без ущерба для согласованности. Этот подход особенно полезен в ситуациях, когда приложение 
    создает большое количество экземпляров в течение  длительного периода времени, когда совместно используемый 
    объект имеет  лишь небольшую часть записываемого состояния или когда создание нового экземпляра сопряжено 
    с большими расходами ресурсов.

### Non Singleton
- __Объекты с записываемым состоянием__. Если имеется бин с большим объемом записываемого состояния, может 
    выясниться, что затраты на синхронизацию превышают затраты на создание нового экземпляра для обработки 
    каждого запроса от зависимого объекта.
- __Объекты с закрытым состоянием__. В ряде случаев зависимым объектам нужен бин, который имеет закрытое 
    состояние, так что зависимые объекты могут проводить свою обработку отдельно друг от друга. В такой 
    ситуации одиночный экземпляр точно не подходит, поэтому необходим неодиночный экземпляр.

---

## BeanFactory в Spring
__BeanFactory__ - это реализация паттерна Фабрика, его функицональность покрывает создание бинов. Так как эта 
фабрика знает многие об объектах приложения, то она может создавать связи между объектами на этапе создания 
экземпляра. Существует несколько реализаций BeanFactory, самая используемся -  
`org.springframework.beans.factory.xml.XmlBeanFactory`. Она загружает бины на основе конфигурационного XML-файла. 

Чтобы создать XmlBeanFactory передайте конструктору InputStream, например:
```java
BeanFactory factory = new XmlBeanFactory(new FileInputStream("myBean.xml"));
```
После этой строки фабрика знает о бинах, но их экземпляры еще не созданы. Чтобы инстанцировать бин нужно вызвать 
метод `getBean()`. Например:
```java
MyBean bean = (MyBean) factory.getBean("myBean"); 
```

---

## Концепции инверсии управления
Разновидности LоС, включают пассивную инверсию зависимостей, или внедрение зависимостей (_Dependency Injection_), 
и активную инверсию зависимостей, или поиск зависимостей (_Dependency Lookup_).

---

## Dependency Lookup
![Dependency Lookup](img/Dependency-Lookup.png)
- Dependency Pull (Извлечение зависимостей)
- Contextualized Dependency Lookup (Контекстуализированный поиск зависимостей), или CDL

### Dependency Pull
[__Dependency Pull__](https://github.com/kovteba/Examples/tree/master/spring1)

### Contextualized Dependency
[__Contextualized Dependency__](https://github.com/kovteba/Examples/tree/master/spring2)

### Lookup Method Injection
Тип [__Lookup Method Injection__](https://github.com/kovteba/Examples/tree/master/spring8) был добавлен в 
_Spring 1.1_ для преодоления проблем, возникающих, когда один бин зависит от другого бина, который имеет 
отличающийся жизненный цикл - в частности, когда одиночный объект (siпgleton) зависит от неодиночного объекта. 
В такой ситуации _Setter Injection_ и _Constructor Injection приводят к тому, что одиночный бин поддерживает 
единственный экземпляр того, что должно быть неодиночным бином. В некоторых случаях необходимо, чтобы 
одиночный бин при возникновении потребности получал новый экземпляр неодиночного бина.

---

## Dependency Injection
![Dependency Injection](img/Dependency-Injection.png)
- Constructor Dependency Injection (Внедрение зависимостей через конструктор)
- Setter Dependency Injection (Внедрение зависимостей через метод установки).

### Constructor Dependency Injection
[__Constructor Dependency lnjection__](https://github.com/kovteba/Examples/tree/master/spring3)

### Setter Dependency Injection
[__Setter Dependency Injection__](https://github.com/kovteba/Examples/tree/master/spring4)

### Method Replacement
В документации Spring замена метода [__Method Replacement__](https://github.com/kovteba/Examples/tree/master/spring9)
классифицируется как форма внедрения, этот прием сильно отличается от того, что было показано до сих пор. 
Ранее внедрение применялось исключительно для поставки бинов с их коллабораторами.   
Используя __Method Replacement__, можно заменить реализацию любого метода любого бина произвольным образом, 
без необходимости в изменении исходного кода этого бина. Например, пусть в приложении используется 
библиотека третьей стороны, и требуется изменить логику определенного метода. Однако вы не в состоянии 
изменить исходный код, поскольку он был предоставлен третьей стороной, так что единственное решение - 
применить __Method Replacement__ для замены логики данного метода собственной реализацией.

Внутренне это достигается созданием подкласса для класса бина динамическим образом. Вы используете библиотеку 
CGLIB и перенаправляете обращения к методу, подлежащему замене, другому бину, который реализует интерфейс
`MethodReplacer`.

---

## Режимы автосвязывания
Существует четыре вида связывания в спринг:
- autowire byName
- autowire byType
- autowire by constructor
- default
- no (автосвязывание отключено; устанавливается по умолчанию)

//- autowiring by @Autowired and @Qualifier annotations

```xml
<?xml version = "l.0" encoding = "UTF-8"?>
<beans xmlns = "http://www.springframework.org/schema/beans"
    xmlns:xsi = "http://www.wЗ.org/2001/XМLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id = "foo" class = "com.apress.prospring4.ch3.Foo"/>
    <bean id = "barl" class = "com.apress.prospring4.ch3.Bar"/>
    <bean id = "targetByName" autowire = "byName"
    class = "com.apress.prospring4.ch3.xml.Target"
    lazy-init="true"/>
    <bean id = "targetByType" autowire="byType"
    class = "com.apress.prospring4.ch3.xml.Target"
    lazy-init = "true"/>
    <bean id = "targetConstructor" autowire = "constructor"
    class = "com.apress.prospring4.ch3.xml.Target" lazy-init = "true"/>
</beans>
```

### ByType
При использовании автосвязывания __bуТуре__ платформа Spring пытается связать каждое свойство целевого бина 
с бином того же самого типа в `ApplicationContext`. Это значит, что если в целевом бине присутствует свойство 
типа `String` и в `ApplicationContext` определен некоторый бин типа `String`, то Spring свяжет бин String со 
свойством String целевого бина. Если в ApplicationContext определено более одного бина типа String, то Spring 
не сможет решить, какой из них выбрать для автосвязывания, и сгенерирует исключение (типа 
`org.springframework.beans.factory.NoSuchBeanDefinitionException`).

### ByConstructor
Режим автосвязывания constructor функционирует подобно режиму __bуТуре__ за исключением того, что для 
выполнения внедрения он применяет конструкторы, а не методы установки. Платформа Spring пытается найти 
соответствие с как можно большим числом аргументов в конструкторе. Таким образом, если бин имеет два
конструктора, первый из которых принимает аргумент String, а второй - аргументы String и Integer, и 
при этом в ApplicationContext определены бины String и Integer, Spring будет использовать конструктор 
с двумя аргументами.

### Default
В режиме __default__ платформа Spring будет автоматически производить выбор между режимами constructor и ЬуТуре. 
Если бин имеет стандартный конструктор (без аргументов), то Spring применяет режим bуТуре, а в противном случае -
режим constructor.

---

## @Autowired
Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой 
задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. 
Аннотация может использоваться над полем или методом для связывания по типу. Чтобы аннотация заработала, необходимо 
указать небольшие настройки в конфигурационном файле спринг с помощью элемента context:annotation-config.

Применимо к :
- Полям
- Сетерам
- Конструкторам

### Поля
Анотация `@Autowired` внедряет зависимости в `private` поля, даже если нет конструктора или сетера. (Reflection)

Но внедрение через поля является Bad Practice. 

При внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми 
необходимыми зависимостями. Это означает, что:    
- Существует способ (путем вызова конструктора по-умолчанию) создать объект с использованием new в состоянии, 
    когда ему не хватает некоторых из его обязательных зависимостей, и использование приведет к NullPointerException
- Такой класс не может быть использован вне DI-контейнеров (тесты, другие модули) и нет способа кроме рефлексии 
    предоставить ему необходимые зависимости
    
__Неизменность__     
В отличие от способа с использованием конструктора, внедрение через поля не может использоваться для присвоения 
зависимостей `final`-полям, что приводит к тому, что ваши объекты становятся изменяемыми

### Сетер
Сеттеры следует использовать для инъекций опциональных зависимостей. Класс должен быть способен функционировать, 
даже если они не были предоставлены. Зависимости могут быть изменены в любое время после создания объекта. 

Официальная рекомендация из документации по Spring 3.x поощряет использование сеттеров над конструкторами:  
>Команда Spring главным образом выступает за инъекцию через сеттеры, потому что большое количество аргументов 
>конструктора может стать громоздким, особенно если свойства являются необязательными. Сеттеры также делают 
>объекты этого класса пригодными для реконфигурации или повторной инъекции позже. Управление через JMX MBeans 
>является ярким примером
>
>Некоторые пуристы предпочитают инъекцию на основе конструктора. Предоставление всех зависимостей означает, 
>что объект всегда возвращается в вызывающий код в полностью инициализированном состоянии. Недостатком является 
>то, что объект становится менее поддающимся реконфигурации и повторной инъекции 

### Конструктор
Инъекция через конструкторы хороша для обязательных зависимостей — тех, которые требуются для корректной 
функциональности объекта. Передавая их через конструктор, вы можете быть уверенными в том, что объект 
полностью готов к использованию с момента создания. Поля, присвоенные в конструкторе, также могут быть 
`final`, что позволяет объекту быть полностью неизменным или как минимум защищает необходимые поля.

Одно из следствий использования внедрения через конструктор — это то что теперь невозможна циклическая 
зависимость между двумя объектами, созданными таким образом (в отличие от внедрения через сеттер). Это 
скорее плюс, чем ограничение, поскольку следует избегать циклических зависимостей, что обычно является 
признаком плохой архитектуры. Таким образом предотвращается подобная практика.

Еще одним преимуществом является то, что при использовании __Spring 4.3+__ вы можете полностью отвязать 
ваш класс от конкретного DI-фреймворка. Причина в том, что Spring теперь поддерживает __неявное внедрение 
через конструктор__ для сценариев использования с одним конструктором. Это означает, что вам больше не 
нужны DI-аннотации в вашем классе. Конечно, вы можете достигнуть того же результата с помощью явного 
конфигурирования DI в настройках Spring для данного класса; просто сейчас это сделать гораздо проще.

Что касается Spring 4.x, официальная рекомендация из документации изменилась и теперь инъекция через 
сеттер более не предпочтительна над конструктором:

>Команда Spring главным образом выступает за инъекцию через конструктор, поскольку она позволяет 
>реализовывать компоненты приложения как неизменяемые объекты и гарантировать, что требуемые 
>зависимости не null. Более того, компоненты, внедренные через через конструктор, всегда возвращаются 
>в клиентский код в полностью инициализированном состоянии. Как небольшое замечание, большое число 
>аргументов конструктора является признаком «кода с запашком» и подразумевает, что у класса, вероятно, 
>слишком много обязанностей, и его необходимо реорганизовать, чтобы лучше решать вопрос о разделении ответственности.
 
>Инъекция через сеттер должна использоваться в первую очередь для опциональных зависимостей, которым 
>могут быть присвоены значения по-умолчанию внутри класса. В противном случае, проверки на not-null 
>должны быть использованы везде, где код использует эти зависимости. Одно из преимуществ использования 
>внедрения через сеттеры заключается в том, что они делают объекты класса поддающимися реконфигурации 
>и повторному инжектированию позже

### Заключение    
В основном стоит избегать внедрения через поля. Как альтернативу для внедрения следует использовать 
сеттеры или конструкторы. У каждого из них есть свои преимущества и недостатки в зависимости от ситуации. 
Однако так как эти подходы можно смешивать, это не выбор «или-или» и вы можете в одном классе комбинировать 
инъекцию и через сеттер, и через конструктор. Конструкторы больше подходят для обязательных зависимостей 
и при нужде в неизменяемых объектах. Сеттеры лучше подходят для опциональных зависимостей.

---

## @Qualifier
В слечае когда два бина подходят возникает неопределенность, эта анотация использоуется какой бин нужно использовать
```java
   @Autowired
   public MusicPlayer(@Qualifier("rockMusic") Music music) {
      this.music = music;
   }
```

---

## Инициализация Bean
- @PostConstruct
- init-method
- Interface InitializingBean

К одному и тому же экземпляру бина можно применять все механизмы. В этом случае Spring вызывает метод, 
аннотированный `@PostConstruct`, затем метод `InitializingBean.afterPropertiesSet()` и, наконец, 
ваш метод инициализации, указанный в конфигурационном файле.

### @PostConstruct
При инициализации бина  
`@PostConstruct` или `init-method` в XML файле сообщает Spring, что нужно вызвать метод отмеченный аннотацией или 
указаный в конфигурационном файле, после окончания конфигурирования бина.

Применение метода инициализации является идеальным способом удостовериться в правильности конфигурации бинов. 
Благодаря этому механизму вы можете получить все преимущества loC, не теряя контроля, который дает 
определение зависимостей вручную. Единственное ограничение метода инициализации связано с тем, что он не 
может принимать аргументы. Можно определять любой возвращаемый тип, хотя он игнорируется Spriпg, и 
можно даже использовать статический метод, но этот метод не должен принимать аргументы.

[Examples...](https://github.com/kovteba/Examples/tree/master/spring10)

### init method
[Examples...](https://github.com/kovteba/Examples/tree/master/spring10)

### Interface InitializingBean
Интерфейс `InitializingBean`, предлагаемый в Spring, позволяет определять внутри бина код, который будет 
выполняться, когда бин получает уведомление о том, что платформа Spring завершила его конфигурирования. 
Подобно методу инициализации, это дает возможность проверить допустимость конфигурации бина, предоставляя 
наряду с этим любые стандартные значения. В интерфейсе `InitializingBean` определен единственный метод 
`afterPropertiesSet()`, который служит той же цели, что и метод `init()`

[Examples...](https://github.com/kovteba/Examples/tree/master/spring11)

---

## Уничтожение Bean
- @PreDestroy
- destroy-method
- Interface DisposableBean

Spring запускает эти методы непосредственно перед уничтожением бина.

Как и в случае с созданием бина, при уничтожении бина можно использовать все механизмы на одном и том 
же экземпляре бина. В такой ситуации Spring сначала вызывает метод, аннотированный `@PreDestroy`, 
затем метод `DisposaЬleBean.destroy()` и, наконец, ваш метод уничтожения, сконфигурированный в 
определении XML.

### @PreDestroy
При уничтожении бина

### destroy method

### Interface DisposableBean

---

## @Component
`@Component` - Spring сканирует выделенный пакет в поисках данной аннотации и инициализирует Beans

Добавить в ApplicationContext.xml
```xml
<context:component-scan base-package="kovteba"/>
```

---

## Add list
```java
public class MusicPlayer {
   private List<Music> musicList = new ArrayList<>();
   public void playMusicList(){
      for (Music s : musicList){
         System.out.println("Playing: " + s.getSong());
      }
   }
   public List<Music> getMusicList() { return musicList; }
   public void setMusicList(List<Music> musicList) { this.musicList = musicList; }
}
```
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util-2.5.xsd">

    <bean id="classicMusicBean" class="kovteba.dependencyinjectionbeans.xmlexamples.example3addlist.ClassicalMusic"/>
    <bean id="rockMusicBean" class="kovteba.dependencyinjectionbeans.xmlexamples.example3addlist.RockMusic"/>

    <bean id="musicPlayer" class="kovteba.dependencyinjectionbeans.xmlexamples.example3addlist.MusicPlayer">
        <property name="musicList">
            <list value-type="kovteba.dependencyinjectionbeans.xmlexamples.example3addlist.Music">
                <ref bean="classicMusicBean"/>
                <ref bean="rockMusicBean"/>
            </list>
        </property>
    </bean>

</beans>
```
```java
public class Example3App {
   public static void main(String[] args) {
      ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
      MusicPlayer musicPlayer = context.getBean("musicPlayer", MusicPlayer.class);
      musicPlayer.playMusicList();
      context.close();
   }
}
```

---

## Interface BeanNameAware
Интерфейс BeanNameAware, который бин может реализовать, чтобы получить свое имя, имеет единственный метод: 
`setBeanName(String)`. Платформа Spring вызывает метод setBeanName () после завершения конфигурирования 
бина, но перед любыми обратными вызовами жизненного цикла (инициализации или уничтожения)

Метод `BeanNameAware.setBeanName()` вызывается перед тем, как первый экземпляр бина будет возвращен 
приложению через вызов `ApplicationContext.getBean()`

[Examples...](https://github.com/kovteba/Examples/tree/master/spring12)

---

## FactoryBean
__FactoryBean__ - это бин, который действует как фабрика для других бинов. Фабрики бинов конфигурируются 
внутри `ApplicationContext` подобно обычным бинам, но когда платформа Spring применяет интерфейс 
`FactoryBean` для удовлетворения запроса зависимости или поиска, она не возвращает экземпляр 
`FactoryBean`, а взамен вызывает метод `FactoryBean.getObject()` и возвращает результат этого вызова.

---

## Потокобезопасен ли Spring bean
По умолчанию бин задается как синглтон в Spring. Таким образом все публичные переменные класса могут быть изменены 
одновременно из разных мест. Так что - нет, не является. Однако поменяв область действия бина на `request`, `prototype`, 
`session` он станет потокобезопасным, но это скажется на производительности.









































