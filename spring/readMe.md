# Spring

- [Что такое Spring? Из каких частей состоит Spring Framework?](#Что-такое-Spring?-Из-каких-частей-состоит-Spring-Framework?)
- [Java Naming and Directory Interface](#Java-Naming-and-Directory-Interface)
- [Enterprise Java Beans](#Enterprise-Java-Beans)
- [Объясните суть паттерна DI или IoC](#Объясните-суть-паттерна-DI-или-IoC)
- [Какие преимущества применения Dependency Injection (DI)?](#Какие-преимущества-применения-Dependency-Injection-(DI)?)
- [Какие IoC контейнеры вы знаете?](#Какие-IoC-контейнеры-вы-знаете?)
- [Как реализуется DI в Spring Framework?](#Как-реализуется-DI-в-Spring-Framework?)
- [Какие существуют виды DI? Приведите примеры.](#Какие-существуют-виды-DI?-Приведите-примеры.)
- [Шаблоны проектирования используемые в Spring Framework](#Шаблоны-проектирования-используемые-в-Spring-Framework)
- [Некоторые из важных особенностей и преимуществ Spring Framework?](#Некоторые-из-важных-особенностей-и-преимуществ-Spring-Framework?)
- [Что такое AOP? Как это относиться к IoC?](#Что-такое-AOP?-Как-это-относиться-к-IoC?)
- [Что такое Aspect, Advice, Pointcut, JointPoint и Advice Arguments в АОП?](#Что-такое-Aspect,-Advice,-Pointcut,-JointPoint-и-Advice-Arguments-в-АОП?)
- [В чем разница между Spring AOP и AspectJ АОП?](#В-чем-разница-между-Spring-AOP-и-AspectJ-АОП?)
- [Что такое IoC контейнер Spring?](#Что-такое-IoC-контейнер-Spring?)
- [Что такое Spring бин?](#Что-такое-Spring-бин?)
- [Какое значение имеет конфигурационный файл Spring Bean?](#Какое-значение-имеет-конфигурационный-файл-Spring-Bean?)
- [Каковы различные способы настроить класс как Spring Bean?](#Каковы-различные-способы-настроить-класс-как-Spring-Bean?)
- [Какие вы знаете различные scope у Spring Bean?](#Какие-вы-знаете-различные-scope-у-Spring-Bean?)
- [Что такое жизненный цикл Spring Bean?](#Что-такое-жизненный-цикл-Spring-Bean?)
- [BeanFactory в Spring](#BeanFactory-в-Spring)
- [Как получить объекты ServletContext и ServletConfig внутри Spring Bean?](#Как-получить-объекты-ServletContext-и-ServletConfig-внутри-Spring-Bean?)
- [В чем роль ApplicationContext в Spring?](#В-чем-роль-ApplicationContext-в-Spring?)
- [Что такое связывание в Spring и расскажите об аннотации @Autowired?](#Что-такое-связывание-в-Spring-и-расскажите-об-аннотации-@Autowired?)
- [Каковы различные типы автоматического связывания в Spring?](#Каковы-различные-типы-автоматического-связывания-в-Spring?)
- [Часто используемые аннотации Spring](#Часто-используемые-аннотации-Spring)
- [Является ли Spring bean потокобезопасным?](#Является-ли-Spring-bean-потокобезопасным?)
- [Как создать ApplicationContext в программе Java?](#Как-создать-ApplicationContext-в-программе-Java?)
- [Можем ли мы иметь несколько файлов конфигурации Spring?](#Можем-ли-мы-иметь-несколько-файлов-конфигурации-Spring?)
- [Каким образом можно управлять транзакциями в Spring?](#Каким-образом-можно-управлять-транзакциями-в-Spring?)
- [Каким образом Spring поддерживает DAO?](#Каким-образом-Spring-поддерживает-DAO?)
- [](#)

## Что такое Spring? Из каких частей состоит Spring Framework?
--Spring-- - фреймворк с открытым исходным кодом, предназначеный для упрощения разработки enterprise-приложений. 
Одним из главным преимуществом Spring является его слоистая архитектура, позволяющая вам самим определять какие 
компоненты будут использованы в вашем приложении. Модули Spring построены на базе основного контейнера, который 
определяет создание, конфигурация и менеджмент бинов.
Основные модули:  
- Основной контейнер - предоставляет основной функционал Spring. Главным компонентом контейнера является 
    __BeanFactory__ - реализация паттерна Фабрика. BeanFactory позволяет разделить конфигурацию приложения и 
    информацию о зависимостях от кода.
- __Spring context__ - конфигурационный файл, который предоставляет информация об окружающей среде для Spring. 
    Сюда входят такие enterprise-сервисы, как JNDI, EJB, интернационализация, валиадция и т.п.
- __Spring AOP__ - отвечает за интеграцию аспектно-ориентированного программирования во фреймворк. Spring AOP 
    обеспечивает сервис управления транзакциями для Spring-приложения.
- __Spring DAO__ - абстрактный уровень Spring JDBC DAO предоставляет иерархию исключений и множество сообщений об 
    ошибках для разных БД. Эта иерархия упрощает обработку исключений и значительно уменьшает количество кода, 
    которое вам нужно было бы написать для таких операций, как, например, открытие и закрытие соединения.
- __Spring ORM__ - отвечает за интеграцию Spring и таких популярных ORM-фреймворков, как Hibernate, iBatis и JDO.
- __Spring Web module__ - классы, которые помогают упростить разработку Web (авторизация, доступ к бинам Spring-а из web).
- __Spring MVC framework__ - реализация паттерна MVC для построения Web-приложений.
    
## Java Naming and Directory Interface
__Java Naming and Directory Interface (JNDI)__ — это набор Java API, организованный в виде службы каталогов, 
который позволяет Java-клиентам открывать и просматривать данные и объекты по их именам. Как любое другое Java API, 
как набор интерфейсов, JNDI не зависит от нижележащей реализации. В дополнению к этому, он предоставляет реализацию 
--service provider interface (SPI)__, которая позволяет службам каталогов работать в паре с каким-либо фреймворком. 
Это может быть сервер, файл или база данных.

Концепция JNDI основана на двух основных определениях: ассоциация и контекст.    
__Ассоциация__ (англ. binding) — это соответствие JNDI-имени и объекта.   
__Контекст__ (англ. context) — это среда, в которой хранится набор ассоциаций между объектами и именами.

## Enterprise Java Beans
__EJB (Enterprise Java Beans)__ – это фреймворк для построение бизнес-логики приложения.

## Объясните суть паттерна DI или IoC
__Dependency injection (DI)__ - паттерн проектирования и архитектурная модель, так же известная как 
__Inversion of Control (IoC)__. DI описывает ситуацию, когда один объект реализует свой функционал через 
другой объект. Например, соединение с базой данных передается конструктору объекта через аргумент, 
вместо того чтобы конструктор сам устанавливал соединение. Существуют три формы внедрения (но не типа) 
зависимостей: сэттер, конструктор и внедрение путем интерфейса.   
DI - это способ достижения слабой связанности. IoC предоставляет возможность объекту получать ссылки на 
свои зависимости. Обычно это реализуется через lookup-метод. Преимущество IoC в том, что эта модель позволяет 
отделить объекты от реализации механизмов, которые он использует. В результате мы получаем большую гибкость 
как при разработке приложений, так и при их тестировании.

## Какие преимущества применения Dependency Injection (DI)?
К преимуществам DI можно отнести:  
- Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения 
    объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую 
    этот код очень прост - при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
- Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. 
    Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
- Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению 
    зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, 
    удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) 
    зависимостей там, где они нужны - внутри зависимого класса. Это приводит к распространению зависимостей 
    по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация 
    об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию 
    в XML-файлах или Java классах).
- Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена 
    зависимостей. Это особенно полезно при тестировании приложения.
- Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает 
    проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд 
    средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе
    
## Какие IoC контейнеры вы знаете?
Spring является IoC контейнером. Помимо него существуют HiveMind, Avalon, PicoContainer и т.д.

## Как реализуется DI в Spring Framework?
Реализация __DI__ в __Spring__ основана на двух ключевых концепциях Java - компонентах JavaBean и интерфейсах. При 
использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей 
внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java 
классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые __POJO__ (Plain Old Java 
Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые 
являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при 
проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов 
можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для 
удовлетворения их зависимости.


## Какие существуют виды DI? Приведите примеры.
Существует два типа DI: через сэттер и через конструктор.
Через сэттер: обычно во всех java beans используются гэттеры и сэттеры для их свойств:  
```java
class NameBean {
   String name;
   public void setName(String s){
      name = a;
   }
   public String getName(){
      return name;
   }
}
```
Мы создаем экземпляр бина NameBean (например, bean1) и устанавливаем нужное свойство, например:
```java
bean1.setName("Marfa");
```
Используя Spring реализация была бы такой:
```xml
<bean id="bean1" class="NameBean">
    <property name="name">
        <value>Marfa</value>
    </property>
</bean>
```
Это и называет DI через сэттер.   
Пример внедрения зависимости между объектами:
```xml
<bean id="bean1" class="bean1impl">
    <property name="game">
        <ref bean="bean2"/>
    </property>
</bean>
<bean id="bean2" class="bean2impl"/>
```
Через конструктор: используется конструктор с параметрами. Например:
```java
class NameBean {
   String name;
   public NameBean(String name){
      this.name = name;
   }
}
bean1 = new NameBean("NAME");
```
Используя Spring это выглядело бы так:
```xml
<bean id="bean1" class="bean1impl">
    <constructor-arg>
        <value>Marfa</value>
    </constructor-arg>
</bean>
```

## Шаблоны проектирования используемые в Spring Framework
Spring Framework использует множество шаблонов проектирования, например:
- Singleton Pattern: Creating beans with default scope.
- Factory Pattern: Bean Factory classes
- Prototype Pattern: Bean scopes
- Adapter Pattern: Spring Web and Spring MVC
- Proxy Pattern: Spring Aspect Oriented Programming support
- Template Method Pattern: JdbcTemplate, HibernateTemplate etc
- Front Controller: Spring MVC DispatcherServlet
- Data Access Object: Spring DAO support
- Dependency Injection and Aspect Oriented Programming

## Некоторые из важных особенностей и преимуществ Spring Framework?
__Spring Framework__ обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, 
которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно 
определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с 
платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности.
- Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.
- Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, 
    что дает преимущества в командной разработке, переносимости модулей и т.д..
- Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI  lookup (поиска).
- Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие 
    как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. 
    Всё это настраивается в едином формате и упрощает поддержку приложения.
    
## Что такое AOP? Как это относиться к IoC?
__Аспектно-ориентированное программирование (АОП)__ - парадигма программирования, основанная на идее разделения 
функциональности для улучшения разбиения программы на модули. AOP и Spring - взаимодополняющие технологии, которые 
позволяют решать сложные проблемы путем разделения функционала на отдельные модули. АОП предоставляет возможность 
реализации сквозной логики - т.е. логики, которая применяется к множеству частей приложения - в одном месте и 
обеспечения автоматического применения этой логики по всему приложению. Подход Spring к АОП заключается в создании 
"динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения 
сквозной логики.

## Что такое Aspect, Advice, Pointcut, JointPoint и Advice Arguments в АОП?
Основные понятия АОП:
- __Аспект__ (англ. aspect) - модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение 
    остального кода, применяя совет в точках соединения, определённых некоторым срезом.
- __Совет__ (англ. advice) - фрагмент кода, который должен выполняться в отдельной точке соединения. Существует 
    несколько типов советов, совет может быть выполнен до, после или вместо точки соединения.
- __Точка соединения__ (англ. joinpoint) - это четко определенная точка в выполняемой программе, где следует 
    применить совет. Типовые примеры точек соединения включают обращение к методу, собственно Method Invocation, и
    нициализацию класса и создание экземпляра объекта. Многие реализации АОП позволяют использовать вызовы методов 
    и обращения к полям объекта в качестве точек соединения.
- __Срез__ (англ. pointcut) - набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному 
    совету. Самые удобные реализации АОП используют для определения срезов синтаксис основного языка (например, в 
    AspectJ применяются Java-сигнатуры) и позволяют их повторное использование с помощью переименования и комбинирования.
- __Связывание__(англ. weaving) представляет собой процесс действительной вставки аспектов в определенную точку 
    кода приложения. Для решений АОП времени компиляции это делается на этапе компиляции, обычно в виде 
    дополнительного шага процесса сборки. Аналогично, для решений АОП времени выполнения связывание происходит 
    динамически во время выполнения. В AspectJ поддерживается еще один механизм связывания под названием связывание 
    во время загрузки (load-time weaving - LTW), который перехватывает лежащий в основе загрузчик классов JVM и 
    обеспечивает связывание с байт-кодом, когда он загружается загрузчиком классов.
- __Цель__(англ. target) - это объект, поток выполнения которого изменяется каким-то процессом АОП. На целевой 
    объект часто ссылаются как на объект, снабженный советом.
- __Внедрение__ (англ. introduction, введение) - представляет собой процесс, посредством которого можно изменить 
    структуру объекта за счет введения в него дополнительных методов или полей, изменение иерархии наследования 
    для добавления функциональности аспекта в инородный код. Обычно реализуется с помощью некоторого метаобъектного 
    протокола (англ. metaobject protocol, MOP).
    
## В чем разница между Spring AOP и AspectJ АОП?
AspectJ де-факто является стандартом реализации АОП. Реализация АОП от Spring имеет некоторые отличия:
- Spring AOP немного проще, т.к. нет необходимости следить за процессом связывания.
- Spring AOP поддерживает аннотации AspectJ, таким образом мы можем работать в спринг проекте похожим образом с 
    AspectJ проектом.
- Spring AOP поддерживает только proxy-based АОП и может использовать только один тип точек соединения - Method 
    Invocation. AspectJ поддерживает все виды точек соединения.
- Недостатком Spring AOP является работа только со своими бинами, которые существуют в Spring Context.

## Что такое IoC контейнер Spring?
По своей сути __IoC__, а, следовательно, и __DI__, направлены на то, чтобы предложить простой механизм для 
предоставления зависимостей компонента (часто называемых коллабораторами объекта) и управления этими зависимостями 
на протяжении всего их жизненного цикла. Компонент, который требует определенных зависимостей, зачастую называют 
зависимым объектом или, в случае IoC, целевым объектом. IoC предоставляет службы, через которые компоненты могут 
получать доступ к своим зависимостям, и службы для взаимодействия с зависимостями в течение их времени жизни. 
В общем случае IoC может быть расщеплена на два подтипа: инверсия управления (Dependency Injection) и инверсия 
поиска (Dependency Lookup).   
__Инверсия управления__ — это крупная часть того, что делает Spring, и ядро реализации Spring основано на инверсии 
управления, хотя также предоставляются и средства Dependency Lookup. Когда платформа Spring предоставляет 
коллабораторы зависимому объекту автоматически, она делает это с использованием инверсии управления 
(Dependency Injection). В приложении, основанном на Spring, всегда предпочтительнее применять Dependency Injection 
для передачи коллабораторов зависимым объектам вместо того, чтобы заставлять зависимые объекты получать 
коллабораторы через поиск.

## Что такое Spring бин?
Термин __бин__ (англ. Bean) - в Spring используется для ссылки на любой компонент, управляемый контейнером. 
Обычно бины на определенном уровне придерживаются спецификации JavaBean, но это не обязательно особенно если 
для связывания бинов друг с другом планируется применять Constructor Injection. Для получения экземпляра бина 
используется ApplicationContext. IoC контейнер управляет жизненным циклом спринг бина, областью видимости и внедрением.

## Какое значение имеет конфигурационный файл Spring Bean?
Конфигурационный файл спринг определяет все бины, которые будут инициализированы в Spring Context. При создании 
экземпляра Spring ApplicationContext будет прочитан конфигурационный xml файл и выполнены указанные в нем 
необходимые инициализации. Отдельно от базовой конфигурации, в файле могут содержаться описание перехватчиков 
(interceptors), view resolvers, настройки локализации и др...

## Каковы различные способы настроить класс как Spring Bean?
Существует несколько способов работы с классами в Spring:
XML конфигурация:
```xml
<bean name="myBean" class="kovteba.beans.MyBean"></bean>
```
Java based конфигурация. Все настройки и указания бинов прописываются в java коде:
```java
@Configuration
@ComponentScan
public class MyConfiguration {
   
   @Bean
   public MyService getService(){
      return new MyService();
   }
}
```
Для извлечения бина из контекста используется следующий подход:
```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class );
MyService service = ctx.getBean(MyService.class );
```
Annotation based конфигурация. Можно использовать внутри кода аннотации @Component, @Service, @Repository, 
@Controller для указания классов в качестве спринг бинов. Для их поиска и управления контейнером прописывается 
настройка в xml файле:
```xml
<context:component-scan base-package="kovteba.beans"/>
```

## Какие вы знаете различные scope у Spring Bean?
В Spring предусмотрены различные области времени действия бинов:
- __Singleton__  может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если 
    не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.
- __prototype__  создается новый экземпляр при каждом запросе.
- __request__   аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. 
    Создается новый экземпляр при каждом HTTP request.
- __session__  новый бин создается в контейнере при каждой новой HTTP сессии.
- __global-session__: используется для создания глобальных бинов на уровне сессии для Portlet  приложений.

## Что такое жизненный цикл Spring Bean?
__Жизненный цикл Spring бина__  время существования класса. Spring бины инициализируются при инициализации Spring 
контейнера и происходит внедрение всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё содержимое. 
Если нам необходимо задать какое-либо действие при инициализации и уничтожении бина, то нужно воспользоваться 
методами `init()` и `destroy()`. Для этого можно использовать аннотации `@PostConstruct` и `@PreDestroy`.
```java
@PostConstruct
public void init(){
   System.out.println("INIT")
}
@PreDestroy
public void destroy(){
   System.out.println("DESTROY")
}
```
Или через xml конфигурацию:
```xml
<bean name="myBean" class="kovteba.MyBean" init-method="init" destroy-method="destroy">
    <property name="someProp" ref="someProp"></property>
</bean>
```

## BeanFactory в Spring
__BeanFactory__ - это реализация паттерна Фабрика, его функицональность покрывает создание бинов. Так как эта 
фабрика знает многие об объектах приложения, то она может создавать связи между объектами на этапе создания 
экземпляра. Существует несколько реализаций BeanFactory, самая используемся -  
"org.springframework.beans.factory.xml.XmlBeanFactory". Она загружает бины на основе конфигурационного XML-файла. 
Чтобы создать XmlBeanFactory передайте конструктору InputStream, например:
```java
BeanFactory factory = new XmlBeanFactory(new FileInputStream("myBean.xml"));
```
После этой строки фабрика знает о бинах, но их экземпляры еще не созданы. Чтобы инстанцировать бин нужно вызвать 
метод `getBean()`. Например:
```java
MyBean bean = (MyBean) factory.getBean("myBean"); 
```
## Как получить объекты ServletContext и ServletConfig внутри Spring Bean?
Доступны два способа для получения основных объектов контейнера внутри бина:
- Реализовать один из Spring*Aware (ApplicationContextAware, ServletContextAware, ServletConfigAware и др.) интерфейсов.
- Использовать автоматическое связывание @Autowired в спринг. Способ работает внутри контейнера спринг.
```java
@Autowired
ServletContext servletContext
```

## В чем роль ApplicationContext в Spring?
В то время, как BeanFactory используется в простых приложениях, Application Context - это более сложный контейнер. 
Как и BeanFactory он может быть использован для загрузки и связывания бинов, но еще он предоставляет:
- возможность получения текстовых сообщений, в том числе поддержку интернационализации;
- общий механизм работы с ресурсами;
- события для бинов, которые зарегестрированы как слушатели.  
Из-за большей функциональности рекомендуется использование Application Context вместо BeanFactory. Последний 
используется только в случаях нехватки ресурсов, например при разработке для мобильных устройств

## Что такое связывание в Spring и расскажите об аннотации @Autowired?
Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой 
задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. 
Аннотация может использоваться над полем или методом для связывания по типу. Чтобы аннотация заработала, необходимо 
указать небольшие настройки в конфигурационном файле спринг с помощью элемента context:annotation-config.

## Каковы различные типы автоматического связывания в Spring?
Существует четыре вида связывания в спринг:
- autowire byName
- autowire byType
- autowire by constructor
- autowiring by @Autowired and @Qualifier annotations

## Часто используемые аннотации Spring
- `@Controller` - класс фронт контроллера в проекте Spring MVC.
- `@RequestMapping` - позволяет задать шаблон маппинга URI в методе обработчике контроллера.
- `@ResponseBody` - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON.
- `@PathVariable` - задает динамический маппинг значений из URI внутри аргументов метода обработчика.
- `@Autowired` - используется для автоматического связывания зависимостей в spring beans.
- `@Qualifier` - используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например 
    одинаковых имен\типов).
- `@Service` - указывает что класс осуществляет сервисные функции.
- `@Scope` - указывает scope у spring bean.
- `@Configuration`, `@ComponentScan` и `@Bean` - для java based configurations.
- AspectJ аннотации для настройки aspects и advices, `@Aspect`, `@Before`, `@After`, `@Around`, `@Pointcut` и др.

## Является ли Spring bean потокобезопасным?
По умолчанию бин задается как синглтон в Spring. Таким образом все публичные переменные класса могут быть изменены 
одновременно из разных мест. Так что - нет, не является. Однако поменяв область действия бина на request, prototype, 
session он станет потокобезопасным, но это скажется на производительности.

## Как создать ApplicationContext в программе Java?
В независимой Java программе ApplicationContext можно создать следующим образом:
`AnnotationConfigApplicationContext` - при использовании Spring в качестве автономного приложения можно создать 
инициализировать контейнер с помощью аннотаций.   
Пример:
```java
ApplicationContext context = new ApplicationConfigApplicatoinContext("bean.xml");
```
`ClassPathXmlApplicationContext` - получает информацию из xml-файла, находящегося в classpath.   
Пример:
```java
ApplicationContext context = new ClassPathXmlApplicatoinContext("bean.xml");
```
`FileSystemXmlApplicationContext` - получает информацию из xml-файла, но с возможностью загрузки файла конфигурации 
из любого места файловой системы.   
Пример:
```java
ApplicationContext context = new FileSystemXmlApplicatoinContext("bean.xml");
```
`XmlWebApplicationContext` - получает информацию из xml-файла за пределами web-приложения.

## Можем ли мы иметь несколько файлов конфигурации Spring?
С помощью указания contextConfigLocation можно задать несколько файлов конфигурации Spring. Параметры указываются 
через запятую или пробел.

## Каким образом можно управлять транзакциями в Spring?
Транзакциями в Spring управляют с помощью __Declarative Transaction Management__ (программное управление). 
Используется аннотация `@Transactional` для описания необходимости управления транзакцией. В файле конфигурации 
нужно добавить настройку transactionManager для DataSource.

## Каким образом Spring поддерживает DAO?
Spring DAO предоставляет возможность работы с доступом к данным с помощью технологий вроде JDBC, Hibernate в 
удобном виде. Существуют специальные классы: JdbcDaoSupport, HibernateDaoSupport, JdoDaoSupport, JpaDaoSupport.  

Класс `HibernateDaoSupport` является подходящим суперклассом для Hibernate DAO. Он содержит методы для получения 
сессии или фабрики сессий. Самый популярный метод - getHibernateTemplate(), который возвращает HibernateTemplate. 
Этот темплейт оборачивает checked-исключения Hibernate в runtime-исключения, позволяя вашим DAO оставаться 
независимыми от исключений Hibernate.   
![HibernateDaoSupport](img/HibernateDaoSupport.jpg)













