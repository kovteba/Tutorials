- [Понятие процесс](#Понятие-процесс)
- [Понятие поток](#Понятие-поток)
- [Понятие синхронизация потоков](#Понятие-синхронизация-потоков)
- [Способы запустить поток?](#Способы-запустить-поток?)
- [Как принудительно остановить поток?](#Как-принудительно-остановить-поток?)
- [Дайте определение понятию “поток-демон”.](#Дайте-определение-понятию-“поток-демон”.)
- [Как создать поток-демон?](#Как-создать-поток-демон?)
- [Как получить текущий поток?](#Как-получить-текущий-поток?)
- [Дайте определение понятию “монитор”](#Дайте-определение-понятию-“монитор”)
- [Как приостановить выполнение потока?](#Как-приостановить-выполнение-потока?)
- [В каких состояниях может пребывать поток?](#В-каких-состояниях-может-пребывать-поток?)
- [Что является монитором при вызове нестатического и статического метода?](#Что-является-монитором-при-вызове-нестатического-и-статического-метода?)
- [Что является монитором при выполнении участка кода метода?](#Что-является-монитором-при-выполнении-участка-кода-метода?)
- [](#)

## Понятие процесс
__Процесс__ — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Процессы 
изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между 
процессами осуществляется с помощью специальных средств). Для каждого процесса _ОС_ создает так называемое 
__«виртуальное адресное пространство»__, к которому процесс имеет прямой доступ. Это пространство принадлежит 
процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, 
как виртуальное пространство процесса проецируется на физическую память.

## Понятие поток
Один поток (_«нить»_ или _«трэд»_) – это одна единица исполнения кода. Каждый поток последовательно выполняет 
инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.

## Понятие синхронизация потоков
Синхронизация относится к многопоточности. Синхронизированный блок кода может быть выполнен только одним 
потоком одновременно.

Java поддерживает несколько потоков для выполнения. Это может привести к тому, что два или более потока получат доступ 
к одному и тому же полю или объекту. Синхронизация — это процесс, который позволяет выполнять все параллельные потоки 
в программе синхронно. Синхронизация позволяет избежать ошибок согласованности памяти, вызванных непоследовательным 
доступом к общей памяти.  
Когда метод объявлен как синхронизированный — нить держит монитор для объекта, метод которого исполняется. Если 
другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, пока другой поток не 
отпустит монитор.  
Синхронизация достигается в Java использованием зарезервированного слова `synchronized`. Вы можете использовать 
его в своих классах определяя синхронизированные методы или блоки. Вы не сможете использовать `synchronized` в 
переменных или атрибутах в определении класса.

## Способы запустить поток?
С помощью класса, реализующего `Runnable`  
- Создать объект класса `Thread`.
- Создать объект класса, реализующего интерфейс `Runnable`
-Вызвать у созданного объекта `Thread` метод `start()` (после этого запустится метод `run()` у переданного объекта, 
    реализующего `Runnable`)
С помощью класса, расширяющего `Thread`   
- Создать объект класса `ClassName extends Thread`.
- Переопределить `run()` в этом классе    
С помощью класса, реализующего `java.util.concurrent.Callable`
- Создать объект класса, реализующего интерфейс `Callable`
- Создать объект `ExecutorService` с указанием пула потоков.
- Создать объект Future. Запуск происходит через метод submit(); Сигнатура: <T> Future<T> submit(Callable<T> task)
```java
class Example implements Runnable {
    @Override
    public void run() { }

    public static void main(String[] args) throws IOException {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        for (int i = 0; i < NUMBER_OF_THREADS; i++) {
            executor.execute(new Example());
        }
        executor.shutdownNow();
        System.out.println(getContent());
    }
}
```
## Как принудительно остановить поток?
В __Java 8__ нет метода, который бы принудительно останавливал поток. Никто не гарантирует, что нить можно остановить. 
Она может остановиться только сама. Java имеет встроенный механизм оповещения потока, который называется 
`Interruption` (прерывание, вмешательство). 
 
Класс `Thread` содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно 
вызвав метод `interrupt()` потока. Проверить же, установлен ли этот флаг, можно двумя способами:  
- Первый способ — вызвать метод bool `isInterrupted()` объекта потока
- Второй — вызвать статический метод bool `Thread.interrupted()`.  
Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает 
состояние флага и сбрасывает его. Заметьте что `Thread.interrupted()` — статический метод класса `Thread`, и его 
вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается 
только изнутри потока и позволяет потоку проверить своё состояние прерывания.
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        long millisOut = System.currentTimeMillis() + 1000;

        while (!Thread.interrupted()){
            System.out.println(currentThread().getName() + " MyThread");
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                System.out.println(currentThread().getName() + " is interrupted");
                break;
            }
            if (millisOut <= System.currentTimeMillis()){
                currentThread().interrupt();
            }
        }
    }
}
```   
У методов, приостанавливающих выполнение потока, таких как `sleep()`, `wait()` и `join()` есть одна 
особенность — если во время их выполнения будет вызван метод `interrupt()` этого потока, они, не дожидаясь 
конца времени ожидания, сгенерируют исключение `InterruptedException`.

## Дайте определение понятию “поток демон”.
__Потоками-демонами__ называются потоки, работающие в фоновом режиме для нашей программы.

В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод `main()` уже завершился, 
но еще выполняются порожденные им потоки, система будет ждать их завершения.
Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, 
и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего 
потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

## Как создать поток демон?
Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод `setDaemon(true)`;
Проверить, является ли поток демоном, можно вызвав его метод `boolean isDaemon()`;
```java
Thread thread = new Thread(new DaemonClass());
thread.setDaemon(true);
System.out.println(thread.isDaemon()); //true
```

## Как получить текущий поток?
Вызвать в коде статический метод `Thread.currentThread()`, который вернет текущий поток.

## Дайте определение понятию “монитор”
Несколько нитей могут мешать друг другу при обращении к одним и тем же данным. Для решения этой проблемы 
придуман _мьютекс_ (он же _монитор_). Он имеет два состояния — объект занят и объект свободен.  
__Монитор(мьютекс)__ — высокоуровневый механизм взаимодействия и синхронизации потоков, обеспечивающий доступ 
к неразделяемым ресурсам.  

__monitorenter__: Когда какой-то нити нужен общий для всех нитей объект, она проверяет _мьютекс_, связанный с этим объектом. 
Если _мьютекс_ свободен, то нить блокирует его (помечает как занятый) и начинает использование общего ресурса. 
После того, как она сделала свои дела, _мьютекс_ разблокируется (помечается как свободен).

Если же нить хочет использовать объект, а _мьютекс_ заблокирован, то нить засыпает в ожидании (`wait`: перемещение 
текущего потока в так называемый wait set монитора и ожидание того, как произойдёт notify.). Когда _мьютекс_, 
освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе. _Мьютекс_ встроен в класс `Object` 
и следовательно он есть у каждого объекта.

Когда одна нить заходит внутрь блока кода, помеченного словом `synchronized`, то Java-машина тут же блокирует _мьютекс_ 
у объекта, который указан в круглых скобках после слова `synchronized`. Больше ни одна нить не сможет зайти в этот 
блок, пока наша нить его не покинет. Как только наша нить выйдет из блока, помеченного `synchronized`, то _мьютекс_ 
тут же автоматически разблокируется и будет свободен для захвата другой нитью. Если же _мьютекс_ был занят, то 
наша нить будет стоять на месте и ждать когда он освободится.

>__contention__ — ситуация, когда несколько сущностей одновременно пытаются владеть одним и тем же ресурсом, который 
>   предназначен для монопольного использования

От того, есть ли contention на владение монитором, очень сильно зависит то, как производится его захват. Монитор 
может находиться в следующих состояниях:   
- `init`: монитор только что создан, и пока никем не был захвачен
- `biased`: (умная оптимизация, появившаяся далеко не сразу) Монитор _«зарезервирован»_ под первый поток, который 
    его захватил. В дальнейшем для захвата этому потоку не нужны дорогие операции, и захват происходит очень быстро. 
    Когда захват пытается произвести другой поток, либо монитор перерезервируется для него (`rebias`), либо монитор 
    переходит в состояние `thin (revoke bias)`. Также есть дополнительные оптимизации, которые действуют сразу на все 
    экземпляры класса объекта, монитор которого пытаются захватить `(bulk revoke/rebias)`
- `thin`: монитор пытаются захватить несколько потоков, но `contention` нет (т.е. они захватывают его не одновременно, 
    либо с очень маленьким нахлёстом). В таком случае захват выполняется с помощью сравнительно дешёвых `CAS`. 
    Если возникает `contention`, то монитор переходит в состояние `inflated`
- `fat/inflated`: синхронизация производится на уровне операционной системы. Поток паркуется и спит до тех пор, 
    пока не настанет его очередь захватить монитор. Даже если забыть про стоимость смены контекста, то когда поток 
    получит управление, зависит ещё и от системного шедулера, и потому времени может пройти существенно больше, 
    чем хотелось бы. При исчезновении contention монитор может вернуться в состояние `thin`

## Как приостановить выполнение потока?
`Thread.sleep()` — статический метод класса `Thread`, который приостанавливает выполнение потока, в котором он был 
вызван. Во время выполнения метода `sleep()` система перестает выделять потоку процессорное время, распределяя его 
между другими потоками.   
Метод `sleep()` может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока 
он не будет остановлен прерыванием (в этом случае он сгенерирует исключение `InterruptedException`).  
`suspend`, `stop` и `resume` — они deprecated.

## В каких состояниях может пребывать поток?
Поток может быть в следующем состоянии: созданный, запущенный, блокированный, остановленный, в режиме ожидания, 
в режиме ожидания по времени (`NEW`, `RUNNABLE`, `BLOCKED`, `TERMINATED`, `WAITING`, `TIMED_WAITING`).

## Что является монитором при вызове нестатического и статического метода?
Для нестатического метода — текущий объект `this`. Для статического метода — объекта типа `Class`, соответствующий 
классу, в котором определен этот метод.

## Что является монитором при выполнении участка кода метода?
Монитором является объект, указанный в блоке `synchronized` участка кода:  
```java
synchronized (synchedList) {
    synchedList.wait();
}
```
## synchronized. wait/notify/notifyAll. Как есть примитивы аналоги из пакета j.u.c?
__Дальше тезисы:__
- `synchronized` — ключевое слово, обозначающее скоуп критической секции. Можно ставить напротив объявления 
    метода, или в виде блока в коде.  
- `wait()` — ожидание треда до тех пор, пока он не будет разбужен другим тредом через notify/notifyAll.
- У `wait()` есть перегруженные версии с таймаутами.
- Тред ставится в `wait-set` на объекте
- Перед вызовом `wait()` нужно захватить монитор на данном объекте (через synchronized)
- Магия `wait()` — он отпускает лок на мониторе объекта после вызова, так чтобы в дальнейшем другой тред мог 
    захватить монитор и вызвать `notify`/`notifyAll`  
- `notify()` — будит один из ожидающих тредов, но Важно! — лок на объекте не отпускает, т.е ожидающий тред 
    разбужен будет, но с ожиданием входа в критическую секцию объекта (т.к как будто остановился на `synchronized`). 
    Так что если после notify есть тяжелые операции, это затормозит ожидающий тред, т.к тред с notify еще не отпустил 
    монитор  
- `notifyAll()` — будут разбужены все треды в wait-set, но при этом далее между тредами происходит 
    contention («сражение») за монитор
- Тред на `wait()` может быть разбужен также через interrupt, или через spurious wake-up, или по таймауту
- Так что условие выполнения, которого ожидает тред, проверяется в цикле while, а не в if
- Примитив-аналог — Condition

