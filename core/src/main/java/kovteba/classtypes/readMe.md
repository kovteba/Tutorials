# Class Types 

+ [Top level class (Обычный класс).](toplevelclass)
+ [Abstract class (Абстрактный класс).](abstractclass)
+ [Final class (Финализированный класс).](finalclass)
+ [Interfaces (Интерфейс).](interface)
+ [Enum (Перечисление).](enums)
+ [Nested class (Вложенный класс):](nestedclass)
    + [Static nested class (Статический вложенный класс);](nestedclass#Static-nested-class)
    + [Member inner class (Простой внутренний класс);](nestedclass#Member-inner-class)
    + [Local inner class (Локальный класс);](nestedclass#Local-inner-class)
    + [Anonymous inner class (Анонимный класс).](nestedclass#Anonymous-inner-class)
- [Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?](#Чем-абстрактный-класс-отличается-от-интерфейса?-В-каких-случаях-следует-использовать-абстрактный-класс,-а-в-каких-интерфейс?)
- [Что имеет более высокий уровень абстракции: класс, абстрактный класс или интерфейс?](#Что-имеет-более-высокий-уровень-абстракции:-класс,-абстрактный-класс-или-интерфейс?)
- [Immutable class](#Immutable-class)
- [](#)

## Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
+ В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
+ Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). 
    Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
+ Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной 
    реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. 
    Все методы интерфейса неявно объявляются как `public abstract` или (начиная с Java 8) `default` - методами с 
    реализацией по-умолчанию, а поля - `public static final`.
+ Интерфейсы позволяют создавать структуры типов без иерархии.
+ Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет 
    собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все 
подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части 
собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения 
иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, 
реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. 
Во всех остальных случаях лучше использовать интерфейсы.

## Что имеет более высокий уровень абстракции: класс, абстрактный класс или интерфейс?
Интерфейс.

## Immutable class
__Неизменяемый класс__ - это класс, состояние которого нельзя изменить после создания.
Пример: `String` - лучший пример неизменяемого класса. Создав строку, вы не сможете ее изменить.

Неизменяемый класс очень прост для понимания, он имеет только одно состояние.  
Неизменяемые классы являются потокобезопасными. Это самое большое преимущество неизменяемого класса, потому что, - 
вам не нужно применять синхронизацию для неизменяемых объектов. Также, неизменяемый класс может быть полезен при 
помещении объекта неизменяемого класса в HashMap или может использоваться для целей кэширования, поскольку его 
значение не изменится.    
Неизменяемые объекты по умолчанию являются потокобезопасными.

__Создания неизменяемого класса:__
- __Финализируйте свой класс:__  
    Если вы финализируете свой класс - ни один класс не сможет его расширить, следовательно, не сможет переопределить 
    методы этого класса.  
- __Пометьте все переменные класса модификаторами доступа private и final:__
    Если вы сделаете переменную экземпляра `private` - ни один внешний класс не сможет получить доступ к переменным 
    экземпляра, и, если вы сделаете их `final` - вы не сможете их изменить.   
- __Скажите «нет» методам-мутаторам:__   
    Не создавайте метод set для некоторых переменных класса, тогда не будет возможности явно изменить состояние 
    переменных экземпляра.   
- __Выполните клонирование изменяемых объектов при возврате из метода получения:__   
    Если вы вернете клон объекта из метода get, то вернется объект. При этом, ваш оригинальный объект останется 
    без изменений.