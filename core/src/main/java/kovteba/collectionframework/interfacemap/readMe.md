# Interface Map

- [Map](#Map)
- [Methods](#Methods)
- [Map.Entry<K, V>](#Map.Entry<K,-V>)
- [HashMap and Hashtable](#HashMap-and-Hashtable)
- [](#)

## Map
![Interface Map](img/interface-map.png)

Данный интерфейс также находится в составе `JDK 1.2` и предоставляет разработчику базовые методы для работы с 
данными вида «ключ — значение». Также как и Collection, он был дополнен дженериками в версии `Java 1.5`и 
в версии `Java 8` появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую 
реализовались в логике приложения (`getOrDefault(Object key, V defaultValue)`, `putIfAbsent(K key, V value)`).

## Methods
- `void clear()`: очищает коллекцию
- `boolean containsKey(Object k)`: возвращает true, если коллекция содержит ключ k
- `boolean containsValue(Object v)`: возвращает true, если коллекция содержит значение v
- `Set<Map.Entry<K, V>> entrySet()`: возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
- `boolean equals(Object obj)`: возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
- `boolean isEmpty`: возвращает true, если коллекция пуста
- `V get(Object k)`: возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то 
    возвращается значение null
- `V getOrDefault(Object k, V defaultValue)`: возвращает значение объекта, ключ которого равен k. Если такого 
    элемента не окажется, то возвращается значение defaultVlue
- `V put(K k, V v)`: помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с 
    подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он 
    уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
- `V putIfAbsent(K k, V v)`: помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет 
    элемента с подобным ключом.
- `Set<K> keySet()`: возвращает набор всех ключей отображения
- `Collection<V> values()`: возвращает набор всех значений отображения
- `void putAll(Map<? extends K, ? extends V> map)`: добавляет в коллекцию все объекты из отображения map
- `V remove(Object k)`: удаляет объект с ключом k
- `int size()`: возвращает количество элементов коллекции

## Map.Entry<K, V>
- `boolean equals(Object obj)`: возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему
- `K getKey()`: возвращает ключ объекта отображения
- `V getValue()`: возвращает значение объекта отображения
- `V setValue(V v)`: устанавливает для текущего объекта значение v
- `int hashCode()`: возвращает хеш-код данного объекта

## HashMap and Hashtable
_HashMap_ и _Hashtable_ являются реализациями одного интерфейса Map. Главное отличие данных классов связано с тем, что 
методы класса Hashtable синхронизированы, а HashMap - нет. Кроме этого класс _Hashtable_ в отличии от _HashMap_ не 
разрешает использование `null` в качестве ключей и значений. HashMap допускает хранение `null` ключей и значений, 
но не допускает дублирования ключей. Следует помнить, что hashCode() для null-ключа всегда равен нулю.

Наличие синхронизации в Hashtable снижает производительность кода, использующего данный класс. Для синхронизации 
можно использовать методы класса __Collections: Collections.synchronizedMap(map), Collections.synchronizedList(list)__ 
или __Collections.synchronizedSet(set)__. Но необходимо помнить, что методы синхронизации класса Collections 
возвращают синхронизированный декоратор переданной коллекции, не обеспечивающий синхронизацию элементов 
коллекции в случае итерации элементов.

Полную потокобезопасную синхронизацию набора данных обеспечивает класс ConcurrentHashMap из пакета concurrent.