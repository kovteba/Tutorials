## Interface List 

- [List](#List)
- [Methods](#Methods)
- [ArrayList and LinkedList](#ArrayList-and-LinkedList)
- [ArrayList and Vector](#ArrayList-and-Vector)
- [](#)


## List
- __Interface List__ расширяет функцональность интерфейса `Collection`.  
- __Max capacity__: `Integer.MAX_VALUE - 8` И это не зависит от типа массива. 8 байт резервируются для информации 
    об объекте (mark word).
- __List__ представляет собой коллекцию, в которой допустимы дублирующие значения. 
  Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. 

## Methods
__Некоторые наиболее часто используемые методы интерфейса `List`:__  
- __void add(int index, E obj)__: добавляет в список по индексу index объект obj
- __boolean addAll(int index, Collection<? extends E> col)__: добавляет в список по индексу index все элементы коллекции col. 
    Если в результате добавления список был изменен, то возвращается `true`, иначе возвращается `false`
- __E get(int index)__: возвращает объект из списка по индексу index
- __int indexOf(Object obj)__: возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается `-1`
- __int lastIndexOf(Object obj)__: возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается `-1`
- __ListIterator<E> listIterator ()__: возвращает объект `ListIterator` для обхода элементов списка
- __static <E> List<E> of(элементы)__: создает из набора элементов объект List
- __E remove(int index)__: удаляет объект из списка по индексу index, возвращая при этом удаленный объект
- __E set(int index, E obj)__: присваивает значение объекта obj элементу, который находится по индексу index
- __void sort(Comparator<? super E> comp)__: сортирует список с помощью компаратора comp
- __List<E> subList(int start, int end)__: получает набор элементов, которые находятся в списке между индексами start и end

## ArrayList and LinkedList
Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как 
это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится 
так же за постоянное время. В среднем потому, что массив имеет определенный начальный размер n (в коде это 
параметр capacity), по умолчанию n = 10, при записи n+1 элемента, будет создан новый массив размером (n * 3) / 2 + 1, 
в него будут помещены все элементы из старого массива + новый, добавляемый элемент. В итоге получаем, что при 
добавлении элемента при необходимости расширения массива, время добавления будет значительно больше, нежели 
при записи элемента в готовую пустую ячейку. Тем не менее, в среднем время вставки элемента в конец списка является 
постоянным. Удаление последнего элемента происходит за константное время. Недостатки ArrayList проявляются 
при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в 
списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова 
метода trimToSize().

LinkedList наоборот, за постоянное время может выполнять вставку/удаление элементов в списке (именно вставку и 
удаление, поиск позиции вставки и удаления сюда не входит). Доступ к произвольному элементу осуществляется за 
линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за константное время — 
ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка вовсе не значит, 
что придется перебирать весь список в поисках последнего элемента). В целом же, LinkedList в абсолютных величинах 
проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно 
применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда 
необходимо гарантированное время добавления элемента в список.

Отличие двух коллекций ArrayList и LinkedList связано со способом хранения данных. Реализация ArrayList хранит 
элементы в виде массива, а LinkedList - в виде списка (двунаправленного). Кроме этого, в ArrayList быстрее 
выполняется сортировка, поскольку для ее выполнения данные списка копируются в массив, а копировать из массива 
ArrayList в массив для сортировки быстрее. При большом количестве операций добавления и удаления элементов в 
коллекцию LinkedList должен быть более приемлемым, т.к. при этих операциях не приходится перемещать части массива.


`ArrayList` это список, реализованный на основе массива, а `LinkedList` — это классический двусвязный список, 
основанный на объектах с ссылками между ними.

__ArrayList:__    
- доступ к произвольному элементу по индексу за константное время O(1);
- доступ к элементам по значению за линейное время O(N);
- вставка в конец в среднем производится за константное время O(1);
- удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы находящиеся 
    «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
- вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы находящиеся 
    «правее» смещаются на одну ячейку вправо;
- минимум накладных расходов при хранении.

__LinkedList:__    
- на получение элемента по индексу или значению потребуется линейное время O(N);
- на добавление и удаление в начало или конец списка потребуется константное O(1);
- вставка или удаление в/из произвольного место O(N);
- требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся 
    еще указатели на следующий и предыдущий элементы списка.
    
В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости 
выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления 
или в случаях, когда необходимо гарантированное время добавления элемента в список.

## ArrayList and Vector
Отличия двух коллекций ArrayList и Vector связаны с принципом изменения размера массива при добавлении элементов 
в набор и с синхронизацией элементов набора данных.

__Изменение размера массива__   
Обе коллекции ArrayList и Vector хранят их содержимое в виде массива. Но, когда элемент вставляется в ArrayList 
или Vector, объект должен будет расширить свой внутренний массив, если он исчерпан. Vector по умолчанию удваивает 
размер своего массива, а ArrayList увеличивает размер массива на 50 процентов.

__Синхронизация данных__
Синхронизация набора данных используется в многопоточном приложении, когда несколько потоков пытаются внести 
изменения в наборы данных. Vector изначально определен для использования в многопоточных приложениях, его 
методы синхронизированы, что обеспечивает потокобезопасность, но это приводит к снижению производительности. 
А при использовании ArrayList в многопоточном приложении необходимо синхронизировать блок кода, 
использующего данную коллекцию.