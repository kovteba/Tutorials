# PostgreSQL

- [Intro](#Intro)
- [Представления](#Представления)
- [Ограничения (constraints)](#Ограничения-(constraints))
- [Primary key](#Primary-key)
- [Foreign key](#Foreign-key)
- [](#)
- [Текущая дата и время](#Текущая-дата-и-время)
- [Получить месяц из текущей даты](#Получить-месяц-из-текущей-даты)
- [Приведение типов](#Приведение-типов)
- [](#)
- [Удаление PostgreSQL](#Удаление-PostgreSQL)
- [Переключение БД](#Переключение-БД)
- [Show all databases](#Show-all-databases)
- [Show all tables in DB](#Show-all-tables-in-DB)
- [Install PostgreSQL](#Install-PostgreSQL)
- [Установка пароля для пользователя postgres](#Установка-пароля-для-пользователя-postgres)
- [Список пользователей](#Список-пользователей)
- [Список баз данных](#Список-баз-данных)
- [Как изменить root пароль в PostgreSQL](#Как-изменить-root-пароль-в-PostgreSQL)
- [Как установить PostgreSQL в автозапуск?](#Как-установить-PostgreSQL-в-автозапуск?)
- [Проверяем состояние сервера](#Проверяем-состояние-сервера)
- [Запустить, остановить, перезапустить](#Запустить-остановить-перезапустить)
- [Как посмотреть какая версия PostgreSQL запущена?](#Как-посмотреть-какая-версия-PostgreSQL-запущена?)
- [Connect to database from user](#Connect-to-database-from-user)
- [Работа через оболочку](#Работа-через-оболочку)
- [Команд psql](#Команд-psql)
- [Посмотреть структуру таблицы](#Посмотреть-структуру-таблицы)
- [Какие таблицы в БВ](#Какие-таблицы-в-БВ)
- [Список полезных команд](#Список-полезных-команд)
- [Посмотреть все схемы БД](#Посмотреть-все-схемы-БД)
- [Установить путь к схеме](#Установить-путь-к-схеме)
- [Переключание режима отображения таблиц](#Переключание-режима-отображения-таблиц)
- [Data type](#Data-type)

---

## Intro

Числа фиксированной точности представлены двумя типами — numeric и decimal.
Однако они являются идентичными по своим возможностям. Поэтому мы будем про-
водить изложение на примере типа numeric. Для задания значения этого типа ис-
пользуются два базовых понятия: масштаб (scale) и точность (precision). Масштаб
показывает число значащих цифр, стоящих справа от десятичной точки (запятой).
Точность указывает общее число цифр как до десятичной точки, так и после нее. На-
пример, у числа 12.3456 точность составляет 6 цифр, а масштаб — 4 цифры.
Параметры этого типа данных указываются в круглых скобках после имени типа:
numeric(точность, масштаб). Например, numeric(6, 2).

Его главное достоинство — это обеспечение точных результатов при выполнении вы-
числений, когда это, конечно, возможно в принципе. Это оказывается возможным
при выполнении сложения, вычитания и умножения. Числа типа numeric могут хра-
нить очень большое количество цифр: 131 072 цифры — до десятичной точки (запя-
той), 16 383 — после точки. Однако нужно учитывать, что такая точность достигается
за счет замедления вычислений по сравнению с целочисленными типами и типами с
плавающей точкой. При этом для хранения числа затрачивается больше памяти, чем
в случае целых чисел.
Данный тип следует выбирать для хранения денежных сумм, а также в других случа-
ях, когда требуется гарантировать точность вычислений.
Представителями типов данных с плавающей точкой являются типы real и double
precision. Они представляют собой реализацию стандарта IEEE «Standard 754 for
Binary Floating-Point Arithmetic». Тип данных real может представить числа в диа-
пазоне, как минимум, от 1E−37 до 1E+37 с точностью не меньше 6 десятичных цифр.
Тип double precision имеет диапазон значений примерно от 1E−307 до 1E+308
с точностью не меньше 15 десятичных цифр.

PostgreSQL поддерживает также тип данных float, определенный в стандарте SQL.
В объявлении типа может использоваться параметр: float(p). Если его значение
лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа real,
а если же значение лежит в диапазоне от 25 до 53, то это будет равносильно исполь-
зованию типа double precision. Если же при объявлении типа параметр не исполь-
зуется, то это также будет равносильно использованию типа double precision.

Последним из числовых типов является тип serial. Однако он фактически реализо-
ван не как настоящий тип, а просто как удобная замена целой группы SQL-команд.
Тип serial удобен в тех случаях, когда требуется в какой-либо столбец вставлять
уникальные целые значения, например, значения суррогатного первичного ключа.

Стандартные представители строковых типов — это типы character varying(n) и character(n), где параметр указывает 
максимальное число символов в строке, которую можно сохранить в столбце такого типа. При работе с многобайтовыми 
кодировками символов, например UTF-8, нужно учитывать, что речь идет о символах, а не о байтах. Если сохраняемая 
строка символов будет короче, чем указано в определении типа, то значение типа character будет дополнено 
пробелами до требуемой длины, а значение типа character varying будет сохранено так, как есть. Типы character 
varying(n) и character(n) имеют псевдонимы varchar(n) и char(n) соответственно.

PostgreSQL дополнительно предлагает еще один символьный тип — text. В столбец
этого типа можно ввести сколь угодно большое значение, конечно, в пределах, уста-
новленных при компиляции исходных текстов СУБД.
Документация рекомендует использовать типы text и varchar, поскольку такое
отличительное свойство типа character, как дополнение значений пробелами, на
практике почти не востребовано. В PostgreSQL обычно используется тип text.

Для хранения времени суток служат два типа данных: time и time with time zone.
Первый из них хранит только время суток, а второй — дополнительно — еще и ча-
совой пояс. Однако документация на PostgreSQL не рекомендует использовать тип
time with time zone, поскольку смещение (offset), соответствующее конкретному
часовому поясу, может зависеть от даты перехода на летнее время и обратно, но в
этом типе дата отсутствует.

Оба типа — timestamp и timestamptz — занимают один и тот же объем 8 байтов, но
значения типа timestamptz хранятся, будучи приведенными к нулевому часовому
поясу (UTC), а перед выводом приводятся к часовому поясу пользователя.

На практике при принятии решения о том, какой из этих двух типов — timestamp
или timestamptz — использовать, необходимо учитывать, требуется ли значения,
хранящиеся в таблице, приводить к местному часовому поясу или не требуется. На-
пример, в расписании авиарейсов указывается местное время как для аэропорта от-
правления, так и для аэропорта прибытия. Поэтому в таком случае нужно использо-
вать тип timestamp, чтобы это время не приводилось к текущему часовому поясу
пользователя, где бы он ни находился.
Из двух этих типов данных чаще используется timestamptz.

Логический (boolean) тип может принимать три состояния: истина и ложь, а так-
же неопределенное состояние, которое можно представить значением NULL. Таким
образом, тип boolean реализует трехзначную логику.
В качестве истинного состояния могут служить следующие значения: TRUE, 't',
'true', 'y', 'yes', 'on', '1'.
В качестве ложного состояния могут служить следующие значения: FALSE, 'f',
'false', 'n', 'no', 'off', '0'.

PostgreSQL позволяет создавать в таблицах такие столбцы, в которых будут содер-
жаться не скалярные значения, а массивы переменной длины. Эти массивы могут
быть многомерными и могут содержать значения любого из встроенных типов, а так-
же типов данных, определенных пользователем.

Типы JSON предназначены для сохранения в столбцах таблиц базы данных таких зна-
чений, которые представлены в формате JSON (JavaScript Object Notation). Существу-
ет два типа: json и jsonb. Основное различие между ними заключается в быстродей-
ствии. Если столбец имеет тип json, тогда сохранение значений происходит быстрее,
потому что они записываются в том виде, в котором были введены. Но при последу-
ющем использовании этих значений в качестве операндов или параметров функций
будет каждый раз выполняться их разбор, что замедляет работу. При использовании
типа jsonb разбор производится однократно, при записи значения в таблицу. Это
несколько замедляет операции вставки строк, в которых содержатся значения дан-
ного типа. Но все последующие обращения к сохраненным значениям выполняются
быстрее, т. к. выполнять их разбор уже не требуется.

Есть еще ряд отличий, в частности, тип json сохраняет порядок следования ключей
в объектах и повторяющиеся значения ключей, а тип jsonb этого не делает. Реко-
мендуется в приложениях использовать тип jsonb, если только нет каких-то особых
аргументов в пользу выбора типа json.

PostgreSQL предлагает свое расширение — команду COMMENT, которая позволяет со-
здавать комментарии (описания) к различным объектам базы данных. Эти коммен-
тарии будут также сохраняться в базе данных. Например, для создания описания
столбца city таблицы airports нужно сделать так:
COMMENT ON COLUMN airports.city IS 'Город';
Чтобы увидеть описания столбцов таблицы, нужно в команде \d добавить символ
«+», например:
\d+ airports

---

## Представления
```sql
create view ivan as
select * from consumer
where address_id = 1;
```
Затем можно обратиться к этому представлению
```sql
select * from ivan;
```

---

## Ограничения (constraints)
Теперь перейдем к рассмотрению различных видов ограничений (constraints). Будем
придерживаться того же порядка, в котором они представлены в документации.
Первым будет ограничение CHECK. Для его создания используется ключевое сло-
во CHECK, за которым следует выражение в круглых скобках, содержащее одно или
несколько условий, налагаемых на атрибуты таблицы. Это ограничение бывает двух
видов: уровня атрибута и уровня таблицы. Различие между ними только в синтакси-
ческом оформлении: в обоих случаях в выражении могут содержаться обращения не
только к одному, но и к нескольким атрибутам таблицы. В первом случае ограниче-
ние CHECK является частью определения одного конкретного атрибута, а во втором
случае оно записывается как самостоятельный элемент определения таблицы.

term numeric( 1 ) CHECK ( term = 1 OR term = 2 ),

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого
слова CONSTRAINT. Если же мы этого не сделаем, тогда СУБД сформирует имя автома-
тически. Когда мы задаем имя сами, мы можем выбрать его с учетом сути налагаемых
ограничений, с позиции предметной области. Если же это имя формирует СУБД, оно
будет сформировано «механически», т. к. СУБД не знает ни сути этих ограничений,
ни специфики предметной области.

Следующим видом ограничений, который мы рассмотрим, будет ограничение NOT
NULL. Оно означает, что в столбце таблицы, на который наложено это ограничение,
должны обязательно присутствовать какие-либо определенные значения. При разра-
ботке баз данных, исходя из логики конкретной предметной области, зачастую требу-
ется использовать это ограничение. Как сказано в документации, оно функциональ-
но эквивалентно ограничению CHECK ( column_name IS NOT NULL) , но в PostgreSQL
создание явного ограничения NOT NULL является более эффективным подходом.

Еще один вид ограничений — это ограничение уникальности UNIQUE. Такое огра-
ничение, наложенное на конкретный столбец, означает, что все значения, содержа-
щиеся в этом столбце в различных строках таблицы, должны быть уникальными,
т. е. не должны повторяться. Ограничение уникальности может включать в себя и
несколько столбцов. В этом случае уникальной должна быть уже комбинация их зна-
чений.

---

## Primary key
Переходим к первичным ключам. Как мы уже говорили ранее, этот ключ является
уникальным идентификатором строк в таблице. Ключ может быть как простым, т. е.
включать только один атрибут, так и составным, т. е. включать более одного атрибута.
При этом в отличие от уникального ключа, определяемого с помощью ограничения
UNIQUE, атрибуты, входящие в состав первичного ключа, не могут иметь значений
NULL. Таким образом, определение первичного ключа эквивалентно определению
уникального ключа, дополненного ограничением NOT NULL. Однако не стоит в ре-
альной работе заменять первичный ключ комбинацией ограничений UNIQUE и NOT
NULL, поскольку теория баз данных требует наличия в каждой таблице именно пер-
вичного ключа.
Первичный ключ является частью метаданных, его наличие позволяет другим табли-
цам использовать его в качестве уникального идентификатора строк в данной таб-
лице. Это удобно, например, при создании внешних ключей, речь о которых пойдет
ниже. Перечисленными свойствами обладает также и уникальный ключ.
Если первичный ключ состоит из одного атрибута, то можно указать его непосред-
ственно в определении этого атрибута:
```sql
CREATE TABLE students
( record_book numeric( 5 ) PRIMARY KEY,
...
);
```
А можно сделать это и в виде отдельного ограничения:
```sql
CREATE TABLE students
( record_book numeric( 5 ),
...
PRIMARY KEY ( record_book )
);
```

В случае создания составного первичного ключа имена столбцов, входящих в его со-
став, перечисляются в выражении PRIMARY KEY через запятую:

```sql
PRIMARY KEY ( имя-столбца1, имя-столбца2, ...)
```

При добавлении первичного ключа автоматически создается индекс на основе B-
дерева для поддержки этого ограничения.
В таблице может быть любое число ограничений UNIQUE, дополненных ограниче-
нием NOT NULL, но первичный ключ может быть только один. PostgreSQL допускает
и отсутствие первичного ключа, хотя строгая теория реляционных баз данных не ре-
комендует так поступать.

---

## Foreign key
Завершаем наш обзор различных видов ограничений рассмотрением такого важно-
го понятия, как внешний ключ (foreign key). Внешние ключи являются средством
поддержания так называемой ссылочной целостности (referential integrity) между
связанными таблицами.
```sql
CREATE TABLE progress
( record_book numeric( 5 ) REFERENCES students ( record_book ),
...
);
```
Поскольку внешний ключ в нашем примере ссылается на первичный ключ, можно
использовать сокращенную форму записи этого ограничения, не указывая список ат-
рибутов:
```sql
CREATE TABLE progress
( record_book numeric( 5 ) REFERENCES students,
...
);
```
Можно определить внешний ключ и в форме ограничения уровня таблицы:
```sql
CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
);
```
Ограничению внешнего ключа можно присвоить наименование, как и любому дру-
гому ограничению, с помощью ключевого слова CONSTRAINT.

---

## Варианты удаления
1. Удаление связанных строк из таблицы «Успеваемость», что означает, что при
отчислении студента будет удаляться вся история его успехов в учебе. Эта опе-
рация называется каскадным удалением, и для ее реализации в определение
внешнего ключа добавляются ключевые слова ON DELETE CASCADE.
Например:
```CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
ON DELETE CASCADE
);
```

2. Запрет удаления строки из таблицы «Студенты», если в таблице «Успеваемость»
есть хотя бы одна строка, ссылающаяся на удаляемую строку в таблице «Сту-
денты». Для реализации такой политики в определение внешнего ключа до-
бавляются ключевые слова ON DELETE RESTRICT или ON DELETE NO ACTION.
Если в определении внешнего ключа не предписано конкретное действие, то
по умолчанию используется NO ACTION.
Оба эти варианта означают, что если в ссылающейся таблице, т. е. «Успевае-
мость», есть строки, ссылающиеся на удаляемую строку в таблице «Студенты»,
то операция удаления будет отменена, и будет выведено сообщение об ошибке.
Отличие между этими двумя вариантами лишь в том, что при использовании NO
ACTION можно отложить проверку выполнения ограничения на более поздний
строк в рамках транзакции, а в случае RESTRICT проверка выполняется немед-
ленно.
Поэтому если бы внешний ключ определили таким образом:
````sql
CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
ON DELETE RESTRICT
);
````
или таким:
```
CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
);
```
то при попытке удаления строки из таблицы «Студенты» и наличии в таблице
«Успеваемость» строк, связанных с ней, операция удаления была бы отменена
с выводом сообщения об ошибке.

3. Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость»
значения NULL. Для реализации этого подхода необходимо, чтобы на атрибу-
ты внешнего ключа не было наложено ограничение NOT NULL.
Оформляется этот вариант так:
```sql
CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
ON DELETE SET NULL
);
```

4. Присваивание атрибутам внешнего ключа в строках таблицы «Успеваемость»
значения по умолчанию (DEFAULT), если оно, конечно, было предписано при
создании таблицы.
Оформляется этот вариант так (значение во фразе DEFAULT взято произволь-
ным образом):
```sql

CREATE TABLE progress
( record_book numeric( 5 ) DEFAULT 12345,
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
ON DELETE SET DEFAULT
);
```
Важно учитывать, что если в ссылочной таблице нет строки с тем же значением
ключевого атрибута, которое было предписано во фразе DEFAULT при создании
ссылающейся таблицы, то будет иметь место нарушение ограничения ссылоч-
ной целостности и операция удаления не будет выполнена.
При выполнении операции UPDATE используются эти же варианты подходов по
отношению к обеспечению ссылочной целостности. Аналогом каскадного уда-
ления является каскадное обновление:
```sql

CREATE TABLE progress
( record_book numeric( 5 ),
...
FOREIGN KEY ( record_book )
REFERENCES students ( record_book )
ON UPDATE CASCADE
);
```
В случае каскадного обновления измененные значения ссылочных атрибутов
копируются в ссылающиеся строки ссылающейся таблицы, т. е. новое значение
атрибута record_book из строки таблицы «Студенты» будет скопировано во все
строки таблицы «Успеваемость», ссылающиеся на обновленную строку.

---

## Текущая дата и время
```sql
SELECT current_date;
```
```sql
SELECT current_time;
```
```sql
SELECT current_timestamp;
```

---

## Получить месяц из текущей даты
```sql
select extract('mon' FROM current_timestamp);
```

---

## Приведение типов
```sql
SELECT 'Sep 12, 2016'::date;
```

---

## Удаление PostgreSQL
```
sudo apt-get --purge remove pgadmin3
sudo apt-get --purge remove postgresql\*

sudo rm -r /etc/postgresql/
sudo rm -r /etc/postgresql-common/
sudo rm -r /var/lib/postgresql/
sudo userdel -r postgres
sudo groupdel postgres
```

---

## Переключение БД
```
\connect (or \c) dbname
```

---  

### Show all databases
```
\l
```

--- 

## Show all tables in DB
```
\dt;
```

---   

## Install PostgreSQL
```
$ sudo apt update
$ sudo apt install postgresql postgresql-contrib
```

---

## Установка пароля для пользователя postgres
Логинемся в postgres:
```sudo su postgres -c psql template```

Меняем пароль:
```ALTER USER postgres with PASSWORD 'password';```

---

## Список пользователей
```
select * from pg_shadow;
```

---

   
## Список баз данных
```
select * from pg_database;
```

---

## Подключение к Postgres в Docker Conteiner
```
psql -U postgres
```

---

### Как изменить root пароль в PostgreSQL
```
$ <strong>/usr/local/pgsql/bin/psql postgres postgres
</strong>Password: (oldpassword)
# <strong>ALTER USER postgres WITH PASSWORD ‘tmppassword’;</strong>
$ <strong>/usr/local/pgsql/bin/psql postgres postgres</strong>
Password: (tmppassword)
```

Изменение пароля для обычного пользователя происходит таким же образом. Пользователь root может поменять пароль любому пользователю.
```
# <strong>ALTER USER username WITH PASSWORD ‘tmppassword’;
</strong>
```

---

### Как установить PostgreSQL в автозапуск?
```
$ su - root
# tar xvfz postgresql-8.3.7.tar.gz
# cd postgresql-8.3.7
# cp contrib/start-scripts/linux /etc/rc.d/init.d/postgresql
# chmod a+x /etc/rc.d/init.d/postgresql
```

---

### Проверяем состояние сервера
```
$ <strong>/etc/init.d/postgresql status
</strong>Password:
pg_ctl: server is running (PID: 6171)
/usr/local/pgsql/bin/postgres “-D” “/usr/local/pgsql/data”
[<strong>Замечание</strong>: Это сообщение говорит о том, что сервер запущен и работате нормально]
$ <strong>/etc/init.d/postgresql status</strong>
Password:
pg_ctl: no server running
[<strong>Замечание</strong>: Это сообщение готоворит о том, что сервер не запущен]
```

---

### Запустить остановить перезапустить
```
# <strong>service postgresql stop
</strong>Stopping PostgreSQL: server stopped
ok
# <strong>service postgresql start</strong>
Starting PostgreSQL: ok
# <strong>service postgresql restart</strong>
Restarting PostgreSQL: server stopped
ok
```

---
 
### Как посмотреть какая версия PostgreSQL запущена?
```
$ <strong>/usr/local/pgsql/bin/psql test
</strong>Welcome to psql 8.3.7, the PostgreSQL interactive terminal.
Type:  \copyright for distribution terms
\h for help with SQL commands
\? for help with psql commands
\g or terminate with semicolon to execute query
\q to quit
test=# <strong>select version();</strong>
version
—————————————————————————————————-
PostgreSQL 8.3.7 on i686-pc-linux-gnu, compiled by GCC gcc (GCC) 4.1.2 20071124 (Red Hat 4.1.2-42)
(1 row)
test=#
```

---

### Как создать пользователя в PostgreSQL?
Для этого существуют два метода..

__Метод 1:__ Создаем пользователя в через PSQL шелл, командой CREATE USER.  

```
# <strong>CREATE USER ramesh WITH password ‘tmppassword’;
</strong>CREATE ROLE
```

__Метод 2:__ Создаем пользователя в через шелл команду createuser.  

```
$ <strong>/usr/local/pgsql/bin/createuser sathiya
</strong>Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) n
Shall the new role be allowed to create more new roles? (y/n) n
CREATE ROLE
```

---

### Получаем список всех баз в Postgresql
```
# <strong>\l</strong> 
List of databases
Name | Owner | Encoding
———-+———-+———-
backup | postgres | UTF8
mydb | ramesh | UTF8
postgres | postgres | UTF8
template0 | postgres | UTF8
template1 | postgres | UTF8
```

--- 

### Как узнать время выполнения запроса?

\timing — после выполения данной команды каждый последующий запрос будет показывать время выполнения.

```
# <strong>\timing
</strong>Timing is on.
# <strong>SELECT * from pg_catalog.pg_attribute ;</strong>
Time: 9.583 ms
```

---

### Connect to database from user
```
psql -h localhost database_name user_nickname
```

---

### Работа через оболочку
```
sudo -u postgres psql
```

---

### Команд psql
```
\?
```

---

### Помощь по команде
```
\help <command_name>
```

---

### Посмотреть структуру таблицы
```
\d <table name>
```
---

### Какие таблицы в БВ
```
\d
```

---
### Список полезных команд

\? Справка по командам psql.
\h Справка по SQL: список доступных команд или
синтаксис конкретной команды.
\x Переключает традиционный табличный вы-
вод (столбцы и строки) на расширенный (каж-
дый столбец на отдельной строке) и обратно.
Удобно для просмотра нескольких «широких»
строк.
\l Список баз данных.
\du Список пользователей.
\dt Список таблиц.
\di Список индексов.
\dv Список представлений.
\df Список функций.
\dn Список схем.
\dx Список установленных расширений.
\dp Список привилегий.
\d имя Подробная информация по конкретному объ-
екту базы данных.
\d+ имя И еще более подробная информация по кон-
кретному объекту.
\timing on Показывать время выполнения операторов.

---

## Посмотреть все схемы БД
```sql
\dn
```

---

## Установить путь к схеме
```sql
SHOW search_path;
```
```sql
SET search_path = <schema_name>;
```
DEFAULT : `"$user", public`

Да, действительно, теперь первой будет просматриваться схема bookings. А для об-
ращения к объектам, например, таблицам, в схеме public (если бы они в ней были)
нам пришлось бы указывать имя схемы public перед именами этих объектов. Ес-
ли бы мы решили добавить схему public в список просматриваемых схем, то нужно
было бы включить ее в команду SET:
```sql
SET search_path = bookings, public;  
```

---

### Переключание режима отображения таблиц
```sql
\x
```
Выключение режима введение повторно комады `\x`

---

## Data type

```
PostgreSQL™                        Java SE 8
DATE                               LocalDate
TIME [ WITHOUT TIMEZONE ]          LocalTime
TIMESTAMP [ WITHOUT TIMEZONE ]     LocalDateTime
TIMESTAMP WITH TIMEZONE	           OffsetDateTime
```
















