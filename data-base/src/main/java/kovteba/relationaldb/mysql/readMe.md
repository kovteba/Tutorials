# MySQL

- [Установка MySQL Server](#Установка-MySQL-Server)
- [Настройка аутентификации и привилегий](#Настройка-аутентификации-и-привилегий)
- [Проверка состояния](#Проверка-состояния)
- [Запуск MySQL server](#Запуск-MySQL-server)
- [Остановка MySQL server](#Остановка-MySQL-server)
- [MySQl Versoin](#MySQl-Version)
- [Создание пользователя](#Создание-пользователя)
- [Переименования таблицы](#Переименования-таблицы)
- [Добавить столбец](#Добавить-столбец)
- [Delete column](#Delete-column)
- [Add row](#Add-row)
- [Update row](#Update-row)
- [Delete row](#Delete-row)
- [LIMIT](#LIMIT)
- [Полное удаление данных](#Полное-удаление-данных)
- [Типы данных MySQL](#Типы-данных-MySQL)
- [CHECK](#CHECK)
- [CONSTRAINT](#CONSTRAINT)
- [FOREIGN KEY](#FOREIGN-KEY)
- [ON DELETE и ON UPDATE](#ON-DELETE-и-ON-UPDATE)
- [INNER JOIN](#INNER-JOIN)
- [LEFT JOIN](#LEFT-JOIN)
- [RIGHT JOIN](#RIGHT-JOIN)
- [Многотабличные запросы](#Многотабличные-запросы)
- [Примеры использования многотабличных запросов](#Примеры-использования-многотабличных-запросов)
- [Изменение значения по умолчанию](#Изменение-значения-по-умолчанию)
- [Изменение типа столбца](#Изменение-типа-столбца)
- [](#)

## Установка MySQL Server
```
sudo apt update
sudo apt install mysql-server
sudo mysql_secure_installation
```

## Настройка аутентификации и привилегий
На серверах с Ubuntu, использующей MySQL 5.7 (и более поздние версии), пользователь `root` в `MySQL` по умолчанию 
аутентифицируется с помощью плагина `auth_socket`, а не по паролю. Это в целом более безопасно и удобно во многих 
случаях, но не в случае, когда вам необходимо организовать доступ к `MySQL` со стороны сторонней программы, 
например, phpMyAdmin.  
Для того, чтобы пользователь `root` в `MySQL` мог использовать пароль для входа в систему вам необходимо изменить 
метод аутентификации с `auth_socket` на `mysql_native_password`. Для этого войдите в оболочку MySQL следующей командой:  
```
sudo mysql
```
Далее проверьте, какой метод аутентификации используется для каждого из ваших пользователей MySQL:
```mysql
SELECT user,authentication_string,plugin,host FROM mysql.user;
```
В этом примере ваш пользователь root использует аутентификацию с помощью плагина auth_socket. Для изменения этой 
настройки на использование пароля используйте следующую команду `ALTER USER`. Не забудьте изменить password на 
ваш сильный пароль:
```mysql
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
```
Далее выполните команду `FLUSH PRIVILEGES`, которая применит внесённые изменения:
```mysql
FlUSH PRIVILEGES:
```

## Проверка состояния
```
systemctl status mysql.service
q = exit
```

## Запуск MySQL server
```
$ /etc/init.d/mysql start
```

## Остановка MySQL server
```
$ /etc/init.d/mysql stop
sudo /etc/init.d/mysql stop
```

## MySQl Version
```
mysql --version
```

## Создание пользователя
```
CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';
```

## Переименования таблицы
```mysql
ALTER TABLE oldname RENAME newname
```
## Добавить столбец
```mysql
ALTER TABLE nameTable ADD nameColumn typeColumn;
```

## Delete column
```mysql
ALTER TABLE nameTable DROP nameColumn;
```

## Add row
```mysql
INSERT INTO nameTable (value, .....) values(value,...);
```

## Update row
```mysql
UPDATE nameTable SET nameField = 'value', ... WHERE id=value;
```

## Delete row
```mysql
DELETE FROM nameTable WHERE id=value;
```

## LIMIT
```mysql
SELECT * FROM nameTable WHERE id > 5 LIMIT 10
```
Данным запросом мы получим 10 первых записей. Все остальные отпадут. 
```mysql
SELECT * FROM nameTable WHERE id > 5 LIMIT 10, 20
```
начиная с 10-го номера включительно в количестве 20-ти штук.

## Полное удаление данных
Для полного удаления данных, очистки таблицы применяется команда `TRUNCATE TABLE`
```mysql
TRUNCATE TABLE tableName;
```

## Типы данных MySQL
- __CHAR__: представляет стоку фиксированной длины.
    Длина хранимой строки указыватся в скобках, например, CHAR(10) - строка из десяти символов. И если в таблицу в 
    данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка 
    дополняется 4 проблеми и в итоге все равно будет занимать 10 символов
- __VARCHAR__: представляет стоку переменной длины.
    Длина хранимой строки также указыватся в скобках, например, VARCHAR(10). Однако в отличие от CHAR хранимая строка 
    будет занимать именно столько места, скольо необходимо. Например, если определеная длина в 10 символов, но в 
    столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный 
    байт, который хранит длину строки.

Начиная с __MySQL 5.6__ типы `CHAR` и `VARCHAR` по умолчанию используют кодировку `UTF-8`, которая позволяет 
использовать до 3 байт для хранения символа в заивисимости от языка ( для многих европейских языков по 1 байту на 
символ, для ряда восточно-европейских и ближневосточных - 2 байта, а для китайского, яполнского, корейского - 
по 3 байта на символ).

__Текст неопределенной длины:__
- __TINYTEXT__: представляет текст длиной до 255 байт.
- __TEXT__: представляет текст длиной до 65 КБ.
- __MEDIUMTEXT__: представляет текст длиной до 16 МБ
- __LARGETEXT__: представляет текст длиной до 4 ГБ

__Числовые типы:__
- __TINYINT__: представляет целые числа от -127 до 128, занимает 1 байт
- __BOOL__: фактически не представляет отдельный тип, а является лишь псевдонимом для типа TINYINT(1) и может хранить 
    два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы `TRUE` 
    (представляет число 1) и `FALSE` (предоставляет число 0). Также имеет псевдоним BOOLEAN.
- __TINYINT UNSIGNED__: представляет целые числа от 0 до 255, занимает 1 байт
- __SMALLINT__: представляет целые числа от -32768 до 32767, занимает 2 байтa
- __SMALLINT UNSIGNED__: представляет целые числа от 0 до 65535, занимает 2 байтa
- __MEDIUMINT__: представляет целые числа от -8388608 до 8388607, занимает 3 байта
- __MEDIUMINT UNSIGNED__: представляет целые числа от 0 до 16777215, занимает 3 байта
- __INT__: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта
- __INT UNSIGNED__: представляет целые числа от 0 до 4294967295, занимает 4 байта
- __BIGINT__: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт
- __BIGINT UNSIGNED__: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт
- __DECIMAL__: хранит числа с фиксированной точностью. Данный тип может принимать два параметра _precision_ и 
    scale: DECIMAL(precision, scale). Параметр _precision_ представляет максимальное количество цифр, которые может 
    хранить число. Это значение должно находиться в диапазоне от 1 до 65.
    Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой. Это значение 
    должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.
    Например, в определении следующего столбца:
    ```mysql
    salary DECIMAL(5,2)
    ```
    Число 5 - precision, а число 2 - scale, поэтому данный столбец может хранить значения из диапазона от -999.99 до 999.99.
    Размер данных в байтах для DECIMAL зависит от хранимого значения.
    Данный тип также имеет псевдонимы NUMERIC, DEC, FIXED.
- __FLOAT__: хранит дробные числа с плавающей точкой одинарной точности от -3.4028 * 1038 до 3.4028 * 1038, 
    занимает 4 байта. Может принимать форму FLOAT(M,D), где M - общее количество цифр, а D - количество цифр 
    после запятой
- __DOUBLE__: хранит дробные числа с плавающей точкой двойной точности от -1.7976 * 10308 до 1.7976 * 10308, 
    занимает 8 байт. Также может принимать форму DOUBLE(M,D), где M - общее количество цифр, а D - количество цифр 
    после запятой. Данный тип также имеет псевдонимы REAL и DOUBLE PRECISION, которые можно использовать вместо DOUBLE.
    
__Типы для работы с датой и временем__
- __DATE__: хранит даты с 1 января 1000 года до 31 деабря 9999 года (c "1000-01-01" до "9999-12-31"). По умолчанию 
    для хранения используется формат yyyy-mm-dd. Занимает 3 байта.
- __TIME__: хранит время от -838:59:59 до 838:59:59. По умолчанию для хранения времени применяется формат
    "hh:mm:ss". Занимает 3 байта.
- __DATETIME__: объединяет время и дату, диапазон дат и времени - с 1 января 1000 года по 31 декабря 9999 года 
    (с "1000-01-01 00:00:00" до "9999-12-31 23:59:59"). Для хранения по умолчанию используется формат 
    "yyyy-mm-dd hh:mm:ss". Занимает 8 байт
- __TIMESTAMP__: также хранит дату и время, но в другом диапазоне: от "1970-01-01 00:00:01" UTC до 
    "2038-01-19 03:14:07" UTC. Занимает 4 байта
- __YEAR__: хранит год в виде 4 цифр. Диапазон доступных значений от 1901 до 2155. Занимает 1 байт.

Тип Date может принимать даты в различных форматах, однако непосредственно для хранения в самой бд даты приводятся к 
формату `yyyy-mm-dd`. Некоторые из принимаемых форматов:  
- yyyy-mm-dd - 2018-05-25
- yyyy-m-dd - 2018-5-25
- yy-m-dd - 18-05-25

В таком формате двузначные числа от 00 до 69 воспринимаются как даты в диапазоне 2000-2069. А числа от 70 до 99 как 
диапазон чисел 1970 - 1999.  
- yyyymmdd - 20180525
- yyyy.mm.dd - 2018.05.25

Для времени тип Time использует 24-часовой формат. Он может принимать время в различных форматах:  
- hh:mi - 3:21 (хранимое значение 03:21:00)
- hh:mi:ss - 19:21:34
- hhmiss - 192134

Примеры значений для типов DATETIME и TIMESTAMP:  
- 2018-05-25 19:21:34
- 2018-05-25 (хранимое значение 2018-05-25 00:00:00)

__Составные типы__
- __ENUM__: хранит одно значение из списка допустимых значений. Занимает 1-2 байта
- __SET__: может хранить несколько значений (до 64 значений) из некоторого списка допустимых значений. Занимает 1-8 байт.

__Бинарные типы__
- __TINYBLOB__: хранит бинарные данные в виде строки длиной до 255 байт.
- __BLOB__: хранит бинарные данные в виде строки длиной до 65 КБ.
- __MEDIUMBLOB__: хранит бинарные данные в виде строки длиной до 16 МБ
- __LARGEBLOB__: хранит бинарные данные в виде строки длиной до 4 ГБ

## CHECK
Атрибут `CHECK` задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после `CHECK` 
указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст 
клиентов не может быть меньше 0 или больше 100:
```mysql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) CHECK(Email !=''),
    Phone VARCHAR(20) CHECK(Phone !='')
);
```
Также CHECK можно использовать на уровне таблицы:
```mysql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
);
```

## CONSTRAINT
С помощью ключевого слова `CONSTRAINT` можно задать имя для ограничений. Они указываются после ключевого слова 
`CONSTRAINT` перед атрибутами на уровне таблицы:
```mysql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20) NOT NULL,
    CONSTRAINT customers_pk PRIMARY KEY(Id),
    CONSTRAINT customer_phone_uq UNIQUE(Phone),
    CONSTRAINT customer_age_chk CHECK(Age >0 AND Age<100)
);
```
Смысл установки имен ограничений заключается в том, что впоследствии через эти имена мы сможем управлять 
ограничениями - удалять или изменять их.

Установить имя можно для ограничений `PRIMARY KEY`, `CHECK`, `UNIQUE`, а также `FOREIGN KEY`

## FOREIGN KEY
Для создания ограничения внешнего ключа после FOREIGN KEY указывается столбец таблицы, который будет представляет 
внешний ключ. А после ключевого слова REFERENCES указывается имя связанной таблицы, а затем в скобках имя связанного 
столбца, на который будет указывать внешний ключ.
```mysql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT, 
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
 
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);
```

## ON DELETE и ON UPDATE
С помощью выражений `ON DELETE` и `ON UPDATE` можно установить действия, которые выполняются соответственно при 
удалении и изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:   
- __CASCADE__: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных 
    строк в главной таблице.
- __SET NULL__: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего 
    ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)
- __RESTRICT__: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.
- __NO ACTION__: то же самое, что и RESTRICT.
- __SET DEFAULT__: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение 
    по умолчанию, которое задается с помощью атрибуты DEFAULT. Несмотря на то, что данная опция в принципе доступна, 
    однако движок InnoDB не поддерживает данное выражение.


## INNER JOIN
```mysql
SELECT * FROM nomenclature;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Книга     |
|  2 | Табуретка |
|  3 | Карандаш  |
+----+-----------+
SELECT * FROM description;
+----+---------------------+
| id | description         |
+----+---------------------+
|  1 | Замечательная книга |
|  3 | Красный карандаш    |
|  5 | Зелёная машинка     |
+----+---------------------+
```
Этот тип объединения позволяет извлекать строки, которые обязательно присутствуют во всех объединяемых таблицах.

В простейшем случае (без указания условий отбора), выборка вернёт т.н. декартово произведение, в котором каждая строка 
одной таблицы будет сопоставлена с каждой строкой другой таблицы
```mysql
SELECT * FROM nomenclature INNER JOIN description;
+----+-----------+----+---------------------+
| id | name      | id | description         |
+----+-----------+----+---------------------+
|  1 | Книга     |  1 | Замечательная книга |
|  2 | Табуретка |  1 | Замечательная книга |
|  3 | Карандаш  |  1 | Замечательная книга |
|  1 | Книга     |  3 | Красный карандаш    |
|  2 | Табуретка |  3 | Красный карандаш    |
|  3 | Карандаш  |  3 | Красный карандаш    |
|  1 | Книга     |  5 | Зелёная машинка     |
|  2 | Табуретка |  5 | Зелёная машинка     |
|  3 | Карандаш  |  5 | Зелёная машинка     |
+----+-----------+----+---------------------+
```
Как правило, декартово произведение таблиц требуется нечасто, чаще требуется выбрать только те записи, которые 
сопоставлены друг другу. Сделать это можно, если задать условие отбора, используя `ON` или `USING`.
```mysql
SELECT * FROM nomenclature INNER JOIN description using(id);
+----+----------+---------------------+
| id | name     | description         |
+----+----------+---------------------+
|  1 | Книга    | Замечательная книга |
|  3 | Карандаш | Красный карандаш    |
+----+----------+---------------------+
```
Запрос вернул только две записи, поскольку именно столько строк имеют одинаковые идентификаторы в обеих таблицах.

Использование `USING` обусловлено тем, что в таблицах ключевой столбец имеет одно и тоже имя - id. В противном случае, 
надо было бы использовать `ON`.
Помимо конструкции `INNER JOIN` внутреннее объединение можно объявить так же через `CROSS JOIN`, `JOIN` и запятую в 
объявлении `FROM`. Следующие четыре запроса вернут одинаковый результат:
```mysql
SELECT * FROM nomenclature INNER JOIN description;
SELECT * FROM nomenclature CROSS JOIN description;
SELECT * FROM nomenclature JOIN description;
SELECT * FROM nomenclature, description;
```
Если объединять таблицы через запятую, то нельзя использовать конструкции `ON` и `USING`, поэтому условие может быть 
задано только в конструкции `WHERE`. Например, это может выглядеть так:
```mysql
SELECT * FROM nomenclature, description WHERE nomenclature.id = description.id;
+----+----------+----+---------------------+
| id | name     | id | description         |
+----+----------+----+---------------------+
|  1 | Книга    |  1 | Замечательная книга |
|  3 | Карандаш |  3 | Красный карандаш    |
+----+----------+----+---------------------+
```
Поскольку поле id не является однозначным, приходится доуточнять в каком контексте оно используется через указание 
имени таблицы.

## LEFT JOIN
```mysql
SELECT * FROM nomenclature;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Книга     |
|  2 | Табуретка |
|  3 | Карандаш  |
+----+-----------+
SELECT * FROM description;
+----+---------------------+
| id | description         |
+----+---------------------+
|  1 | Замечательная книга |
|  3 | Красный карандаш    |
|  5 | Зелёная машинка     |
+----+---------------------+
```
Левосторонние объединения позволяют извлекать данные из таблицы, дополняя их по возможности данными из другой таблицы.

К примеру, чтобы получить полный список наименований товаров вместе с их описанием, нужно выполнить следующий запрос:
```mysql
SELECT * FROM nomenclature LEFT JOIN description USING(id);
+----+-----------+---------------------+
| id | name      | description         |
+----+-----------+---------------------+
|  1 | Книга     | Замечательная книга |
|  2 | Табуретка | NULL                |
|  3 | Карандаш  | Красный карандаш    |
+----+-----------+---------------------+
```
Поскольку для наименования Табуретка в таблице описаний нет подходящей записи, то в поле description подставился `NULL`. 
Это справедливо для всех записей, у которых нет подходящей пары.

Если дополнить предыдущий запрос условием на проверку несуществования описания, то можно получить список записей, 
которые не имеют пары в таблице описаний:
```mysql
SELECT id, name FROM nomenclature LEFT JOIN description USING(id) WHERE description IS NULL;
+----+-----------+
| id | name      |
+----+-----------+
|  2 | Табуретка |
+----+-----------+
```
По сути это и есть основное назначение внешних запросов - показывать расхождение данных двух таблиц.

Кроме того, при таком объединении обязательным является условие, которое задаётся через `ON` или `USING`. Без него запрос 
будет выдавать ошибку.

## RIGHT JOIN
```mysql
SELECT * FROM nomenclature;
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Книга     |
|  2 | Табуретка |
|  3 | Карандаш  |
+----+-----------+
SELECT * FROM description;
+----+---------------------+
| id | description         |
+----+---------------------+
|  1 | Замечательная книга |
|  3 | Красный карандаш    |
|  5 | Зелёная машинка     |
+----+---------------------+
```
Этот вид объединений практически ничем не отличается от левостороннего объединения, за тем исключением, что данные 
берутся из второй таблицы, которая находится справа от конструкции `JOIN`, и сравниваются с данными, которые находятся 
в таблице, указанной перед конструкцией.
```mysql
SELECT * FROM nomenclature RIGHT JOIN description USING(id);
+----+---------------------+----------+
| id | description         | name     |
+----+---------------------+----------+
|  1 | Замечательная книга | Книга    |
|  3 | Красный карандаш    | Карандаш |
|  5 | Зелёная машинка     | NULL     |
+----+---------------------+----------+
```
Как видно, теперь уже поле name содержит нулевые значения. Также поменялся и порядок расположения столбцов.

Однако, во всех случаях использования правосторонних объединений, запрос можно переписать, используя левостороннее 
объединение, просто поменяв таблицы местами, и наоборот.   
Следующие два запроса равнозначны:
```mysql
SELECT * FROM nomenclature LEFT JOIN description USING(id);
SELECT * FROM description RIGHT JOIN nomenclature USING(id);
```

## Многотабличные запросы
В __MySQL 5.0__ на сегодняшний день можно объединить вплоть до 61 таблицы. Помимо объединений разных таблиц, MySQL 
позволяет объединять таблицу саму с собой. Однако, в любом случае необходимо следить за именами столбцов и таблиц, 
если они будут неоднозначны, то запрос не будет выполнен.

Так, если таблицу просто объединить саму на себя, то возникнет конфликт имён и запрос не выполнится.
```mysql
SELECT * FROM nomenclature JOIN nomenclature;
ERROR 1066 (42000): Not unique table/alias: 'nomenclature'
```
Обойти конфликт имён позволяет использование синонимов (alias) для имён таблиц и столбцов. В следующем примере 
внутреннее объединение будет работать успешнее:
```mysql
SELECT * FROM nomenclature JOIN nomenclature AS t2;
+----+-----------+----+-----------+
| id | name      | id | name      |
+----+-----------+----+-----------+
|  1 | Книга     |  1 | Книга     |
|  2 | Табуретка |  1 | Книга     |
|  3 | Карандаш  |  1 | Книга     |
|  1 | Книга     |  2 | Табуретка |
|  2 | Табуретка |  2 | Табуретка |
|  3 | Карандаш  |  2 | Табуретка |
|  1 | Книга     |  3 | Карандаш  |
|  2 | Табуретка |  3 | Карандаш  |
|  3 | Карандаш  |  3 | Карандаш  |
+----+-----------+----+-----------+
```
MySQL не накладывает ограничений на использование разных типов объединений в одном запросе, поэтому можно формировать 
довольно сложные конструкции:
```mysql
SELECT * FROM nomenclature AS t1 JOIN nomenclature AS t2 LEFT JOIN nomenclature AS t3 ON t1.id = t3.id AND t2.id = t1.id;
+----+-----------+----+-----------+------+-----------+
| id | name      | id | name      | id   | name      |
+----+-----------+----+-----------+------+-----------+
|  1 | Книга     |  1 | Книга     |    1 | Книга     |
|  2 | Табуретка |  1 | Книга     | NULL | NULL      |
|  3 | Карандаш  |  1 | Книга     | NULL | NULL      |
|  1 | Книга     |  2 | Табуретка | NULL | NULL      |
|  2 | Табуретка |  2 | Табуретка |    2 | Табуретка |
|  3 | Карандаш  |  2 | Табуретка | NULL | NULL      |
|  1 | Книга     |  3 | Карандаш  | NULL | NULL      |
|  2 | Табуретка |  3 | Карандаш  | NULL | NULL      |
|  3 | Карандаш  |  3 | Карандаш  |    3 | Карандаш  |
+----+-----------+----+-----------+------+-----------+
```
Помимо выборок использовать объединения можно также и в запросах UPDATE и DELETE

Так, следующие три запроса проделывают одинаковую работу:
```mysql
UPDATE nomenclature AS t1, nomenclature AS t2 SET t1.id = t2.id WHERE t1.id = t2.id;
UPDATE nomenclature AS t1 JOIN nomenclature AS t2 SET t1.id = t2.id WHERE t1.id = t2.id;
UPDATE nomenclature AS t1 JOIN nomenclature AS t2 USING(id) SET t1.id = t2.id;
```
Таким же образом работают и многтабличные удаления
```mysql
DELETE t1 FROM nomenclature AS t1 JOIN nomenclature AS t2 USING(id) WHERE t2.id > 10;
```
Следует помнить, что при использовании многотабличных запросов на удаление или обновление данных, нельзя включать в 
запрос конструкции `ORDER` BY и `LIMIT`. Впрочем, это ограничение очень эффективно обходится при помощи временных 
таблиц.

## Примеры использования многотабличных запросов
```mysql
SELECT SQL_CALC_FOUND_ROWS
    dgs.dogovor_id,
    dgs.dogovor_name,
    dgs.abonent_name,
    dgs.abonent_type,
    dgs.address_fiz,
    dgs.date_conclusion,
    dgs.date_annulment,
    dgs.threshold,
    ubc.usum

FROM
    billing_dogovors dgs
        LEFT JOIN
            billing_users_balance ubc
        ON
            ubc.udate = CURDATE()
                AND
            dgs.dogovor_id = ubc.dogovor_id
    
WHERE
    dgs.dogovor_name LIKE "%123%"
    
ORDER BY
    dgs.dogovor_name ASC

LIMIT
    0, 58
```
В данном случае идёт выборка первых 58 клиентов из таблицы договоров с привязкой баланса на текущий день, у которых в 
имени договора содержится "123" и сортировкой по имени (номеру) договора. Поскольку список договоров может не 
совпадать со списком балансов, то используется левостороннее объединение. Помимо этого используется 
`SQL_CALC_FOUND_ROWS` для подсчёта общего количества найденных строк, чтобы организовать страничную навигацию.
```mysql
SELECT SQL_CALC_FOUND_ROWS
    pft.udate,
    dgs.dogovor_name,
    pft.usum,
    ptt.type_name
    
FROM
    billing_profit pft
        LEFT JOIN
            billing_dogovors dgs
        USING( dogovor_id ) 
    
        LEFT JOIN
            billing_profit_types ptt
        ON
            pft.profit_type = ptt.type_id
            
WHERE
    pft.udate > CURDATE() - INTERVAL 7 DAY

ORDER BY
    pft.udate DESC,
    dgs.dogovor_name ASC
    
LIMIT 
    0, 30;
```
Данный запрос выводит список платежей с указанием типа платежа и номера договора с сортировкой по дате и номеру 
договора. Также предусмотрен постраничный вывод списка.
```mysql
SELECT SQL_CALC_FOUND_ROWS
    ips.ip,
    ips.segment_id,
    ips.gray_ip,
    ips.ip_mac,
    ips.ip_status,
    ips.ip_type,
    ips.blocked_reason,
    ips.blocked_time,
    ips.comment,
    rts.router_name,
    dgs.dogovor_name,
    ipt.type_name,
    ubc.usum

FROM
    billing_ips ips
        LEFT JOIN
            billing_routers rts
        ON
            ips.segment_id = rts.router_id
        
        LEFT JOIN
            t
        ON
            ips.ip = t.ip
            
        LEFT JOIN
            billing_ip_types ipt
        ON
            ips.ip_type = ipt.type_id,
        
    billing_dogovors dgs
        LEFT JOIN
            billing_users_balance ubc
        ON
            ubc.udate = CURDATE()
                AND
            dgs.dogovor_id = ubc.dogovor_id
    
WHERE
    INET_NTOA(ips.ip) LIKE "%123%"
        AND
    dgs.dogovor_name LIKE "%123%"
        AND
    dgs.dogovor_id = t.dogovor_id
    
ORDER BY ips.ip ASC

LIMIT
    0, 80
```
В этом примере используется одно внутреннее объединение для привязки ip-адресов к договорам, и три внешних 
левосторонних для получения дополнительной информации. Несмотря на внушительный размер, запрос выполняется 
достаточно быстро, поскольку объединения идут по первичным ключам. Так, как результатом должен быть список 
из договоров и привязанных к ним ip-адресов, то используется внутреннее объединение.

Использовать более экзотические конструкции на практике приходится нечасто, поскольку с ростом количества объединяемых 
таблиц резко падает производительность запросов. Сложные задачи, которые требуют серьёзных вычислений, такие, как, 
например, подсчёт балансов всех клиентов, решаются с помощью временных таблиц и довольно простых запросов.

## Изменение значения по умолчанию
```mysql
ALTER TABLE tableName
ALTER COLUMN columnName SET DEFAULT defaultValue;
```

## Изменение типа столбца
```mysql
ALTER TABLE tableName
MODIFY COLUMN tableName CHAR(100) NULL;
```


















